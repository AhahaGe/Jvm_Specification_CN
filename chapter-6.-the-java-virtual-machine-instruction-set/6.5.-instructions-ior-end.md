# 6.5. Instructions \(ior-end\)

#### _ior_

**Operation**

Boolean OR `int`

**Format**

  
_ior_  


**Forms**

_ior_ = 128 \(0x80\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. They are popped from the operand stack. An `int` _result_ is calculated by taking the bitwise inclusive OR of _value1_ and _value2_. The _result_ is pushed onto the operand stack.

#### _irem_

**Operation**

Remainder `int`

**Format**

  
_irem_  


**Forms**

_irem_ = 112 \(0x70\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. The `int` _result_ is _value1_ - \(_value1_ / _value2_\) \* _value2_. The _result_ is pushed onto the operand stack.

The result of the _irem_ instruction is such that `(a/b)*b + (a%b)` is equal to `a`. This identity holds even in the special case in which the dividend is the negative `int` of largest possible magnitude for its type and the divisor is -1 \(the remainder is 0\). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor.

**Run-time Exception**

If the value of the divisor for an `int` remainder operator is 0, _irem_ throws an `ArithmeticException`.

#### _ireturn_

**Operation**

Return `int` from method

**Format**

  
_ireturn_  


**Forms**

_ireturn_ = 172 \(0xac\)

**Operand Stack**

..., _value_ →

\[empty\]

**Description**

The current method must have return type `boolean`, `byte`, `short`, `char`, or `int`. The _value_ must be of type `int`. If the current method is a `synchronized` method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread. If no exception is thrown, _value_ is popped from the operand stack of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.

The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.

**Run-time Exceptions**

If the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the current method is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _ireturn_ throws an `IllegalMonitorStateException`. This can happen, for example, if a `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is synchronized.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _ireturn_ throws an `IllegalMonitorStateException`.

#### _ishl_

**Operation**

Shift left `int`

**Format**

  
_ishl_  


**Forms**

_ishl_ = 120 \(0x78\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. An `int` _result_ is calculated by shifting _value1_ left by _s_ bit positions, where _s_ is the value of the low 5 bits of _value2_. The _result_ is pushed onto the operand stack.

**Notes**

This is equivalent \(even if overflow occurs\) to multiplication by 2 to the power _s_. The shift distance actually used is always in the range 0 to 31, inclusive, as if _value2_ were subjected to a bitwise logical AND with the mask value 0x1f.

#### _ishr_

**Operation**

Arithmetic shift right `int`

**Format**

  
_ishr_  


**Forms**

_ishr_ = 122 \(0x7a\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. An `int` _result_ is calculated by shifting _value1_ right by _s_ bit positions, with sign extension, where _s_ is the value of the low 5 bits of _value2_. The _result_ is pushed onto the operand stack.

**Notes**

The resulting value is _floor_\(_value1_ / 2_s_\), where _s_ is _value2_ & 0x1f. For non-negative _value1_, this is equivalent to truncating `int` division by 2 to the power _s_. The shift distance actually used is always in the range 0 to 31, inclusive, as if _value2_ were subjected to a bitwise logical AND with the mask value 0x1f.

#### _istore_

**Operation**

Store `int` into local variable

**Format**

  
_istore_  
_index_  


**Forms**

_istore_ = 54 \(0x36\)

**Operand Stack**

..., _value_ →

...

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack, and the value of the local variable at _index_ is set to _value_.

**Notes**

The _istore_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _istore\_&lt;n&gt;_

**Operation**

Store `int` into local variable

**Format**

  
_istore\_&lt;n&gt;_  


**Forms**

_istore\_0_ = 59 \(0x3b\)

_istore\_1_ = 60 \(0x3c\)

_istore\_2_ = 61 \(0x3d\)

_istore\_3_ = 62 \(0x3e\)

**Operand Stack**

..., _value_ →

...

**Description**

The &lt;_n_&gt; must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack, and the value of the local variable at &lt;_n_&gt; is set to _value_.

**Notes**

Each of the _istore\_&lt;n&gt;_ instructions is the same as _istore_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _isub_

**Operation**

Subtract `int`

**Format**

  
_isub_  


**Forms**

_isub_ = 100 \(0x64\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. The `int` _result_ is _value1_ - _value2_. The _result_ is pushed onto the operand stack.

For `int` subtraction, `a-b` produces the same result as `a+(-b)`. For `int` values, subtraction from zero is the same as negation.

The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type `int`. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical difference of the two values.

Despite the fact that overflow may occur, execution of an _isub_ instruction never throws a run-time exception.

#### _iushr_

**Operation**

Logical shift right `int`

**Format**

  
_iushr_  


**Forms**

_iushr_ = 124 \(0x7c\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. An `int` _result_ is calculated by shifting _value1_ right by _s_ bit positions, with zero extension, where _s_ is the value of the low 5 bits of _value2_. The _result_ is pushed onto the operand stack.

**Notes**

If _value1_ is positive and _s_ is _value2_ & 0x1f, the result is the same as that of _value1_ `>>` _s_; if _value1_ is negative, the result is equal to the value of the expression \(_value1_ `>>` _s_\) + \(2 `<<` ~_s_\). The addition of the \(2 `<<` ~_s_\) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 31, inclusive.

#### _ixor_

**Operation**

Boolean XOR `int`

**Format**

  
_ixor_  


**Forms**

_ixor_ = 130 \(0x82\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. They are popped from the operand stack. An `int` _result_ is calculated by taking the bitwise exclusive OR of _value1_ and _value2_. The _result_ is pushed onto the operand stack.

#### _jsr_

**Operation**

Jump subroutine

**Format**

  
_jsr_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_jsr_ = 168 \(0xa8\)

**Operand Stack**

... →

..., _address_

**Description**

The _address_ of the opcode of the instruction immediately following this _jsr_ instruction is pushed onto the operand stack as a value of type `returnAddress`. The unsigned _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit offset, where the offset is \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution proceeds at that offset from the address of this _jsr_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _jsr_ instruction.

**Notes**

Note that _jsr_ pushes the address onto the operand stack and _ret_ \([§_ret_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ret)\) gets it out of a local variable. This asymmetry is intentional.

In Oracle's implementation of a compiler for the Java programming language prior to Java SE 6, the _jsr_ instruction was used with the _ret_ instruction in the implementation of the `finally` clause \([§3.13](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.13), [§4.10.2.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.2.5)\).

#### _jsr\_w_

**Operation**

Jump subroutine \(wide index\)

**Format**

  
_jsr\_w_  
_branchbyte1_  
_branchbyte2_  
_branchbyte3_  
_branchbyte4_  


**Forms**

_jsr\_w_ = 201 \(0xc9\)

**Operand Stack**

... →

..., _address_

**Description**

The _address_ of the opcode of the instruction immediately following this _jsr\_w_ instruction is pushed onto the operand stack as a value of type `returnAddress`. The unsigned _branchbyte1_, _branchbyte2_, _branchbyte3_, and _branchbyte4_ are used to construct a signed 32-bit offset, where the offset is \(_branchbyte1_ `<<` 24\) \| \(_branchbyte2_ `<<` 16\) \| \(_branchbyte3_ `<<` 8\) \| _branchbyte4_. Execution proceeds at that offset from the address of this _jsr\_w_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _jsr\_w_ instruction.

**Notes**

Note that _jsr\_w_ pushes the address onto the operand stack and _ret_ \([§_ret_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ret)\) gets it out of a local variable. This asymmetry is intentional.

In Oracle's implementation of a compiler for the Java programming language prior to Java SE 6, the _jsr\_w_ instruction was used with the _ret_ instruction in the implementation of the `finally` clause \([§3.13](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.13), [§4.10.2.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.2.5)\).

Although the _jsr\_w_ instruction takes a 4-byte branch offset, other factors limit the size of a method to 65535 bytes \([§4.11](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.11)\). This limit may be raised in a future release of the Java Virtual Machine.

#### _l2d_

**Operation**

Convert `long` to `double`

**Format**

  
_l2d_  


**Forms**

_l2d_ = 138 \(0x8a\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `long`. It is popped from the operand stack and converted to a `double` _result_ using IEEE 754 round to nearest mode. The _result_ is pushed onto the operand stack.

**Notes**

The _l2d_ instruction performs a widening primitive conversion \(JLS §5.1.2\) that may lose precision because values of type `double` have only 53 significand bits.

#### _l2f_

**Operation**

Convert `long` to `float`

**Format**

  
_l2f_  


**Forms**

_l2f_ = 137 \(0x89\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `long`. It is popped from the operand stack and converted to a `float` _result_ using IEEE 754 round to nearest mode. The _result_ is pushed onto the operand stack.

**Notes**

The _l2f_ instruction performs a widening primitive conversion \(JLS §5.1.2\) that may lose precision because values of type `float` have only 24 significand bits.

#### _l2i_

**Operation**

Convert `long` to `int`

**Format**

  
_l2i_  


**Forms**

_l2i_ = 136 \(0x88\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `long`. It is popped from the operand stack and converted to an `int` _result_ by taking the low-order 32 bits of the `long` value and discarding the high-order 32 bits. The _result_ is pushed onto the operand stack.

**Notes**

The _l2i_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_. The _result_ may also not have the same sign as value.

#### _ladd_

**Operation**

Add `long`

**Format**

  
_ladd_  


**Forms**

_ladd_ = 97 \(0x61\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. The values are popped from the operand stack. The `long` _result_ is _value1_ + _value2_. The _result_ is pushed onto the operand stack.

The result is the 64 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type `long`. If overflow occurs, the sign of the result may not be the same as the sign of the mathematical sum of the two values.

Despite the fact that overflow may occur, execution of an _ladd_ instruction never throws a run-time exception.

#### _laload_

**Operation**

Load `long` from array

**Format**

  
_laload_  


**Forms**

_laload_ = 47 \(0x2f\)

**Operand Stack**

..., _arrayref_, _index_ →

..., _value_

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `long`. The _index_ must be of type `int`. Both _arrayref_ and _index_ are popped from the operand stack. The `long` _value_ in the component of the array at _index_ is retrieved and pushed onto the operand stack.

**Run-time Exceptions**

If _arrayref_ is `null`, _laload_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _laload_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _land_

**Operation**

Boolean AND `long`

**Format**

  
_land_  


**Forms**

_land_ = 127 \(0x7f\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. They are popped from the operand stack. A `long` _result_ is calculated by taking the bitwise AND of _value1_ and _value2_. The _result_ is pushed onto the operand stack.

#### _lastore_

**Operation**

Store into `long` array

**Format**

  
_lastore_  


**Forms**

_lastore_ = 80 \(0x50\)

**Operand Stack**

..., _arrayref_, _index_, _value_ →

...

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `long`. The _index_ must be of type `int`, and _value_ must be of type `long`. The _arrayref_, _index_, and _value_ are popped from the operand stack. The `long` _value_ is stored as the component of the array indexed by _index_.

**Run-time Exceptions**

If _arrayref_ is `null`, _lastore_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _lastore_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _lcmp_

**Operation**

Compare `long`

**Format**

  
_lcmp_  


**Forms**

_lcmp_ = 148 \(0x94\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. They are both popped from the operand stack, and a signed integer comparison is performed. If _value1_ is greater than _value2_, the `int` value 1 is pushed onto the operand stack. If _value1_ is equal to _value2_, the `int` value 0 is pushed onto the operand stack. If _value1_ is less than _value2_, the `int` value -1 is pushed onto the operand stack.

#### _lconst\_&lt;l&gt;_

**Operation**

Push `long` constant

**Format**

  
_lconst\_&lt;l&gt;_  


**Forms**

_lconst\_0_ = 9 \(0x9\)

_lconst\_1_ = 10 \(0xa\)

**Operand Stack**

... →

..., &lt;_l_&gt;

**Description**

Push the `long` constant &lt;_l_&gt; \(0 or 1\) onto the operand stack.

#### _ldc_

**Operation**

Push item from run-time constant pool

**Format**

  
_ldc_  
_index_  


**Forms**

_ldc_ = 18 \(0x12\)

**Operand Stack**

... →

..., _value_

**Description**

The _index_ is an unsigned byte that must be a valid index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The run-time constant pool entry at _index_ either must be a run-time constant of type `int` or `float`, or a `reference` to a string literal, or a symbolic reference to a class, method type, or method handle \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\).

If the run-time constant pool entry is a run-time constant of type `int` or `float`, the numeric _value_ of that run-time constant is pushed onto the operand stack as an `int` or `float`, respectively.

Otherwise, if the run-time constant pool entry is a `reference` to an instance of class `String` representing a string literal \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), then a `reference` to that instance, _value_, is pushed onto the operand stack.

Otherwise, if the run-time constant pool entry is a symbolic reference to a class \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), then the named class is resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\) and a `reference` to the `Class` object representing that class, _value_, is pushed onto the operand stack.

Otherwise, the run-time constant pool entry must be a symbolic reference to a method type or a method handle \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\). The method type or method handle is resolved \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\) and a `reference` to the resulting instance of `java.lang.invoke.MethodType` or `java.lang.invoke.MethodHandle`, _value_, is pushed onto the operand stack.

**Linking Exceptions**

During resolution of a symbolic reference to a class, any of the exceptions pertaining to class resolution \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\) can be thrown.

During resolution of a symbolic reference to a method type or method handle, any of the exception pertaining to method type or method handle resolution \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\) can be thrown.

**Notes**

The _ldc_ instruction can only be used to push a value of type `float` taken from the float value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\) because a constant of type `float` in the constant pool \([§4.4.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4)\) must be taken from the float value set.

#### _ldc\_w_

**Operation**

Push item from run-time constant pool \(wide index\)

**Format**

  
_ldc\_w_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_ldc\_w_ = 19 \(0x13\)

**Operand Stack**

... →

..., _value_

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are assembled into an unsigned 16-bit index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is calculated as \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The index must be a valid index into the run-time constant pool of the current class. The run-time constant pool entry at the index either must be a run-time constant of type `int` or `float`, or a `reference` to a string literal, or a symbolic reference to a class, method type, or method handle \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\).

If the run-time constant pool entry is a run-time constant of type `int` or `float`, the numeric _value_ of that run-time constant is pushed onto the operand stack as an `int` or `float`, respectively.

Otherwise, if the run-time constant pool entry is a `reference` to an instance of class `String` representing a string literal \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), then a `reference` to that instance, _value_, is pushed onto the operand stack.

Otherwise, if the run-time constant pool entry is a symbolic reference to a class \([§4.4.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1)\). The named class is resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\) and a `reference` to the `Class` object representing that class, _value_, is pushed onto the operand stack.

Otherwise, the run-time constant pool entry must be a symbolic reference to a method type or a method handle \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\). The method type or method handle is resolved \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\) and a `reference` to the resulting instance of `java.lang.invoke.MethodType` or `java.lang.invoke.MethodHandle`, _value_, is pushed onto the operand stack.

**Linking Exceptions**

During resolution of the symbolic reference to a class, any of the exceptions pertaining to class resolution \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\) can be thrown.

During resolution of a symbolic reference to a method type or method handle, any of the exception pertaining to method type or method handle resolution \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\) can be thrown.

**Notes**

The _ldc\_w_ instruction is identical to the _ldc_ instruction \([§_ldc_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ldc)\) except for its wider run-time constant pool index.

The _ldc\_w_ instruction can only be used to push a value of type `float` taken from the float value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\) because a constant of type `float` in the constant pool \([§4.4.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4)\) must be taken from the float value set.

#### _ldc2\_w_

**Operation**

Push `long` or `double` from run-time constant pool \(wide index\)

**Format**

  
_ldc2\_w_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_ldc2\_w_ = 20 \(0x14\)

**Operand Stack**

... →

..., _value_

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are assembled into an unsigned 16-bit index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is calculated as \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The index must be a valid index into the run-time constant pool of the current class. The run-time constant pool entry at the index must be a run-time constant of type `long` or `double` \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\). The numeric _value_ of that run-time constant is pushed onto the operand stack as a `long` or `double`, respectively.

**Notes**

Only a wide-index version of the _ldc2\_w_ instruction exists; there is no _ldc2_ instruction that pushes a `long` or `double` with a single-byte index.

The _ldc2\_w_ instruction can only be used to push a value of type `double` taken from the double value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\) because a constant of type `double` in the constant pool \([§4.4.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.5)\) must be taken from the double value set.

#### _ldiv_

**Operation**

Divide `long`

**Format**

  
_ldiv_  


**Forms**

_ldiv_ = 109 \(0x6d\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. The values are popped from the operand stack. The `long` _result_ is the value of the Java programming language expression _value1_ / _value2_. The _result_ is pushed onto the operand stack.

A `long` division rounds towards 0; that is, the quotient produced for `long` values in _n_ / _d_ is a `long` value _q_ whose magnitude is as large as possible while satisfying \|_d_ ⋅ _q_\| ≤ \|_n_\|. Moreover, _q_ is positive when \|_n_\| ≥ \|_d_\| and _n_ and _d_ have the same sign, but _q_ is negative when \|_n_\| ≥ \|_d_\| and _n_ and _d_ have opposite signs.

There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the `long` type and the divisor is -1, then overflow occurs and the result is equal to the dividend; despite the overflow, no exception is thrown in this case.

**Run-time Exception**

If the value of the divisor in a `long` division is 0, _ldiv_ throws an `ArithmeticException`.

#### _lload_

**Operation**

Load `long` from local variable

**Format**

  
_lload_  
_index_  


**Forms**

_lload_ = 22 \(0x16\)

**Operand Stack**

... →

..., _value_

**Description**

The _index_ is an unsigned byte. Both _index_ and _index_+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at _index_ must contain a `long`. The _value_ of the local variable at _index_ is pushed onto the operand stack.

**Notes**

The _lload_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _lload\_&lt;n&gt;_

**Operation**

Load `long` from local variable

**Format**

  
_lload\_&lt;n&gt;_  


**Forms**

_lload\_0_ = 30 \(0x1e\)

_lload\_1_ = 31 \(0x1f\)

_lload\_2_ = 32 \(0x20\)

_lload\_3_ = 33 \(0x21\)

**Operand Stack**

... →

..., _value_

**Description**

Both &lt;_n_&gt; and &lt;_n_&gt;+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at &lt;_n_&gt; must contain a `long`. The _value_ of the local variable at &lt;_n_&gt; is pushed onto the operand stack.

**Notes**

Each of the _lload\_&lt;n&gt;_ instructions is the same as _lload_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _lmul_

**Operation**

Multiply `long`

**Format**

  
_lmul_  


**Forms**

_lmul_ = 105 \(0x69\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. The values are popped from the operand stack. The `long` _result_ is _value1_ \* _value2_. The _result_ is pushed onto the operand stack.

The result is the 64 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type `long`. If overflow occurs, the sign of the result may not be the same as the sign of the mathematical multiplication of the two values.

Despite the fact that overflow may occur, execution of an _lmul_ instruction never throws a run-time exception.

#### _lneg_

**Operation**

Negate `long`

**Format**

  
_lneg_  


**Forms**

_lneg_ = 117 \(0x75\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ must be of type `long`. It is popped from the operand stack. The `long` _result_ is the arithmetic negation of _value_, -_value_. The _result_ is pushed onto the operand stack.

For `long` values, negation is the same as subtraction from zero. Because the Java Virtual Machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative `long` results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown.

For all `long` values `x`, `-x` equals `(~x)+1`.

#### _lookupswitch_

**Operation**

Access jump table by key match and jump

**Format**

  
_lookupswitch_  
_&lt;0-3 byte pad&gt;_  
_defaultbyte1_  
_defaultbyte2_  
_defaultbyte3_  
_defaultbyte4_  
_npairs1_  
_npairs2_  
_npairs3_  
_npairs4_  
_match-offset pairs..._  


**Forms**

_lookupswitch_ = 171 \(0xab\)

**Operand Stack**

..., _key_ →

...

**Description**

A _lookupswitch_ is a variable-length instruction. Immediately after the _lookupswitch_ opcode, between zero and three bytes must act as padding, such that _defaultbyte1_ begins at an address that is a multiple of four bytes from the start of the current method \(the opcode of its first instruction\). Immediately after the padding follow a series of signed 32-bit values: _default_, _npairs_, and then _npairs_ pairs of signed 32-bit values. The _npairs_ must be greater than or equal to 0. Each of the _npairs_ pairs consists of an `int` _match_ and a signed 32-bit _offset_. Each of these signed 32-bit values is constructed from four unsigned bytes as \(_byte1_ `<<` 24\) \| \(_byte2_ `<<` 16\) \| \(_byte3_ `<<` 8\) \| _byte4_.

The table _match-offset_ pairs of the _lookupswitch_ instruction must be sorted in increasing numerical order by _match_.

The _key_ must be of type `int` and is popped from the operand stack. The _key_ is compared against the _match_ values. If it is equal to one of them, then a target address is calculated by adding the corresponding _offset_ to the address of the opcode of this _lookupswitch_ instruction. If the _key_ does not match any of the _match_ values, the target address is calculated by adding _default_ to the address of the opcode of this _lookupswitch_ instruction. Execution then continues at the target address.

The target address that can be calculated from the _offset_ of each _match-offset_ pair, as well as the one calculated from _default_, must be the address of an opcode of an instruction within the method that contains this _lookupswitch_ instruction.

**Notes**

The alignment required of the 4-byte operands of the _lookupswitch_ instruction guarantees 4-byte alignment of those operands if and only if the method that contains the _lookupswitch_ is positioned on a 4-byte boundary.

The _match-offset_ pairs are sorted to support lookup routines that are quicker than linear search.

#### _lor_

**Operation**

Boolean OR `long`

**Format**

  
_lor_  


**Forms**

_lor_ = 129 \(0x81\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. They are popped from the operand stack. A `long` _result_ is calculated by taking the bitwise inclusive OR of _value1_ and _value2_. The _result_ is pushed onto the operand stack.

#### _lrem_

**Operation**

Remainder `long`

**Format**

  
_lrem_  


**Forms**

_lrem_ = 113 \(0x71\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. The values are popped from the operand stack. The `long` _result_ is _value1_ - \(_value1_ / _value2_\) \* _value2_. The _result_ is pushed onto the operand stack.

The result of the _lrem_ instruction is such that `(a/b)*b + (a%b)` is equal to `a`. This identity holds even in the special case in which the dividend is the negative `long` of largest possible magnitude for its type and the divisor is -1 \(the remainder is 0\). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor.

**Run-time Exception**

If the value of the divisor for a `long` remainder operator is 0, _lrem_ throws an `ArithmeticException`.

#### _lreturn_

**Operation**

Return `long` from method

**Format**

  
_lreturn_  


**Forms**

_lreturn_ = 173 \(0xad\)

**Operand Stack**

..., _value_ →

\[empty\]

**Description**

The current method must have return type `long`. The _value_ must be of type `long`. If the current method is a `synchronized` method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread. If no exception is thrown, _value_ is popped from the operand stack of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.

The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.

**Run-time Exceptions**

If the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the current method is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _lreturn_ throws an `IllegalMonitorStateException`. This can happen, for example, if a `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is `synchronized`.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _lreturn_ throws an `IllegalMonitorStateException`.

#### _lshl_

**Operation**

Shift left `long`

**Format**

  
_lshl_  


**Forms**

_lshl_ = 121 \(0x79\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

The _value1_ must be of type `long`, and _value2_ must be of type `int`. The values are popped from the operand stack. A `long` _result_ is calculated by shifting _value1_ left by _s_ bit positions, where _s_ is the low 6 bits of _value2_. The _result_ is pushed onto the operand stack.

**Notes**

This is equivalent \(even if overflow occurs\) to multiplication by 2 to the power _s_. The shift distance actually used is therefore always in the range 0 to 63, inclusive, as if _value2_ were subjected to a bitwise logical AND with the mask value 0x3f.

#### _lshr_

**Operation**

Arithmetic shift right `long`

**Format**

  
_lshr_  


**Forms**

_lshr_ = 123 \(0x7b\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

The _value1_ must be of type `long`, and _value2_ must be of type `int`. The values are popped from the operand stack. A `long` _result_ is calculated by shifting _value1_ right by _s_ bit positions, with sign extension, where _s_ is the value of the low 6 bits of _value2_. The _result_ is pushed onto the operand stack.

**Notes**

The resulting value is _floor_\(_value1_ / 2_s_\), where _s_ is _value2_ & 0x3f. For non-negative _value1_, this is equivalent to truncating `long` division by 2 to the power _s_. The shift distance actually used is therefore always in the range 0 to 63, inclusive, as if _value2_ were subjected to a bitwise logical AND with the mask value 0x3f.

#### _lstore_

**Operation**

Store `long` into local variable

**Format**

  
_lstore_  
_index_  


**Forms**

_lstore_ = 55 \(0x37\)

**Operand Stack**

..., _value_ →

...

**Description**

The _index_ is an unsigned byte. Both _index_ and _index_+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `long`. It is popped from the operand stack, and the local variables at _index_ and _index_+1 are set to _value_.

**Notes**

The _lstore_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _lstore\_&lt;n&gt;_

**Operation**

Store `long` into local variable

**Format**

  
_lstore\_&lt;n&gt;_  


**Forms**

_lstore\_0_ = 63 \(0x3f\)

_lstore\_1_ = 64 \(0x40\)

_lstore\_2_ = 65 \(0x41\)

_lstore\_3_ = 66 \(0x42\)

**Operand Stack**

..., _value_ →

...

**Description**

Both &lt;_n_&gt; and &lt;_n_&gt;+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `long`. It is popped from the operand stack, and the local variables at &lt;_n_&gt; and &lt;_n_&gt;+1 are set to _value_.

**Notes**

Each of the _lstore\_&lt;n&gt;_ instructions is the same as _lstore_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _lsub_

**Operation**

Subtract `long`

**Format**

  
_lsub_  


**Forms**

_lsub_ = 101 \(0x65\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. The values are popped from the operand stack. The `long` _result_ is _value1_ - _value2_. The _result_ is pushed onto the operand stack.

For `long` subtraction, `a-b` produces the same result as `a+(-b)`. For `long` values, subtraction from zero is the same as negation.

The result is the 64 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type `long`. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical difference of the two values.

Despite the fact that overflow may occur, execution of an _lsub_ instruction never throws a run-time exception.

#### _lushr_

**Operation**

Logical shift right `long`

**Format**

  
_lushr_  


**Forms**

_lushr_ = 125 \(0x7d\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

The _value1_ must be of type `long`, and _value2_ must be of type `int`. The values are popped from the operand stack. A `long` _result_ is calculated by shifting _value1_ right logically by _s_ bit positions, with zero extension, where _s_ is the value of the low 6 bits of _value2_. The _result_ is pushed onto the operand stack.

**Notes**

If _value1_ is positive and _s_ is _value2_ & 0x3f, the result is the same as that of _value1_ `>>` _s_; if _value1_ is negative, the result is equal to the value of the expression \(_value1_ `>>` _s_\) + \(2L `<<` ~_s_\). The addition of the \(2L `<<` ~_s_\) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 63, inclusive.

#### _lxor_

**Operation**

Boolean XOR `long`

**Format**

  
_lxor_  


**Forms**

_lxor_ = 131 \(0x83\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `long`. They are popped from the operand stack. A `long` _result_ is calculated by taking the bitwise exclusive OR of _value1_ and _value2_. The _result_ is pushed onto the operand stack.

#### _monitorenter_

**Operation**

Enter monitor for object

**Format**

  
_monitorenter_  


**Forms**

_monitorenter_ = 194 \(0xc2\)

**Operand Stack**

..., _objectref_ →

...

**Description**

The _objectref_ must be of type `reference`.

Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes _monitorenter_ attempts to gain ownership of the monitor associated with _objectref_, as follows:

* If the entry count of the monitor associated with _objectref_ is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.
* If the thread already owns the monitor associated with _objectref_, it reenters the monitor, incrementing its entry count.
* If another thread already owns the monitor associated with _objectref_, the thread blocks until the monitor's entry count is zero, then tries again to gain ownership.

**Run-time Exception**

If _objectref_ is `null`, _monitorenter_ throws a `NullPointerException`.

**Notes**

A _monitorenter_ instruction may be used with one or more _monitorexit_ instructions \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) to implement a `synchronized` statement in the Java programming language \([§3.14](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14)\). The _monitorenter_ and _monitorexit_ instructions are not used in the implementation of `synchronized` methods, although they can be used to provide equivalent locking semantics. Monitor entry on invocation of a `synchronized` method, and monitor exit on its return, are handled implicitly by the Java Virtual Machine's method invocation and return instructions, as if _monitorenter_ and _monitorexit_ were used.

The association of a monitor with an object may be managed in various ways that are beyond the scope of this specification. For instance, the monitor may be allocated and deallocated at the same time as the object. Alternatively, it may be dynamically allocated at the time when a thread attempts to gain exclusive access to the object and freed at some later time when no thread remains in the monitor for the object.

The synchronization constructs of the Java programming language require support for operations on monitors besides entry and exit. These include waiting on a monitor \(`Object.wait`\) and notifying other threads waiting on a monitor \(`Object.notifyAll` and `Object.notify`\). These operations are supported in the standard package `java.lang` supplied with the Java Virtual Machine. No explicit support for these operations appears in the instruction set of the Java Virtual Machine.

#### _monitorexit_

**Operation**

Exit monitor for object

**Format**

  
_monitorexit_  


**Forms**

_monitorexit_ = 195 \(0xc3\)

**Operand Stack**

..., _objectref_ →

...

**Description**

The _objectref_ must be of type `reference`.

The thread that executes _monitorexit_ must be the owner of the monitor associated with the instance referenced by _objectref_.

The thread decrements the entry count of the monitor associated with _objectref_. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.

**Run-time Exceptions**

If _objectref_ is `null`, _monitorexit_ throws a `NullPointerException`.

Otherwise, if the thread that executes _monitorexit_ is not the owner of the monitor associated with the instance referenced by _objectref_, _monitorexit_ throws an `IllegalMonitorStateException`.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the second of those rules is violated by the execution of this _monitorexit_ instruction, then _monitorexit_ throws an `IllegalMonitorStateException`.

**Notes**

One or more _monitorexit_ instructions may be used with a _monitorenter_ instruction \([§_monitorenter_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter)\) to implement a `synchronized` statement in the Java programming language \([§3.14](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14)\). The _monitorenter_ and _monitorexit_ instructions are not used in the implementation of `synchronized` methods, although they can be used to provide equivalent locking semantics.

The Java Virtual Machine supports exceptions thrown within `synchronized` methods and `synchronized` statements differently:

* Monitor exit on normal `synchronized` method completion is handled by the Java Virtual Machine's return instructions. Monitor exit on abrupt `synchronized` method completion is handled implicitly by the Java Virtual Machine's _athrow_ instruction.
* When an exception is thrown from within a `synchronized` statement, exit from the monitor entered prior to the execution of the `synchronized` statement is achieved using the Java Virtual Machine's exception handling mechanism \([§3.14](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14)\).

#### _multianewarray_

**Operation**

Create new multidimensional array

**Format**

  
_multianewarray_  
_indexbyte1_  
_indexbyte2_  
_dimensions_  


**Forms**

_multianewarray_ = 197 \(0xc5\)

**Operand Stack**

..., _count1_, \[_count2_, ...\] →

..., _arrayref_

**Description**

The _dimensions_ operand is an unsigned byte that must be greater than or equal to 1. It represents the number of dimensions of the array to be created. The operand stack must contain _dimensions_ values. Each such value represents the number of components in a dimension of the array to be created, must be of type `int`, and must be non-negative. The _count1_ is the desired length in the first dimension, _count2_ in the second, etc.

All of the _count_ values are popped off the operand stack. The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at the index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\). The resulting entry must be an array class type of dimensionality greater than or equal to _dimensions_.

A new multidimensional array of the array type is allocated from the garbage-collected heap. If any _count_ value is zero, no subsequent dimensions are allocated. The components of the array in the first dimension are initialized to subarrays of the type of the second dimension, and so on. The components of the last allocated dimension of the array are initialized to the default initial value \([§2.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3), [§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) for the element type of the array type. A `reference` _arrayref_ to the new array is pushed onto the operand stack.

**Linking Exceptions**

During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in [§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1) can be thrown.

Otherwise, if the current class does not have permission to access the element type of the resolved array class, _multianewarray_ throws an `IllegalAccessError`.

**Run-time Exception**

Otherwise, if any of the _dimensions_ values on the operand stack are less than zero, the _multianewarray_ instruction throws a `NegativeArraySizeException`.

**Notes**

It may be more efficient to use _newarray_ or _anewarray_ \([§_newarray_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.newarray), [§_anewarray_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.anewarray)\) when creating an array of a single dimension.

The array class referenced via the run-time constant pool may have more dimensions than the _dimensions_ operand of the _multianewarray_ instruction. In that case, only the first _dimensions_ of the dimensions of the array are created.

#### _new_

**Operation**

Create new object

**Format**

  
_new_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_new_ = 187 \(0xbb\)

**Operand Stack**

... →

..., _objectref_

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at the index must be a symbolic reference to a class or interface type. The named class or interface type is resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\) and should result in a class type. Memory for a new instance of that class is allocated from the garbage-collected heap, and the instance variables of the new object are initialized to their default initial values \([§2.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3), [§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\). The _objectref_, a `reference` to the instance, is pushed onto the operand stack.

On successful resolution of the class, it is initialized \([§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5)\) if it has not already been initialized.

**Linking Exceptions**

During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in [§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1) can be thrown.

Otherwise, if the symbolic reference to the class, array, or interface type resolves to an interface or is an `abstract` class, _new_ throws an `InstantiationError`.

**Run-time Exception**

Otherwise, if execution of this _new_ instruction causes initialization of the referenced class, _new_ may throw an `Error` as detailed in JLS §15.9.4.

**Notes**

The _new_ instruction does not completely create a new instance; instance creation is not completed until an instance initialization method \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\) has been invoked on the uninitialized instance.

#### _newarray_

**Operation**

Create new array

**Format**

  
_newarray_  
_atype_  


**Forms**

_newarray_ = 188 \(0xbc\)

**Operand Stack**

..., _count_ →

..., _arrayref_

**Description**

The _count_ must be of type `int`. It is popped off the operand stack. The _count_ represents the number of elements in the array to be created.

The _atype_ is a code that indicates the type of array to create. It must take one of the following values:

**Table 6.5.newarray-A. Array type codes**

| Array Type | _atype_ |
| :--- | :--- |
| `T_BOOLEAN` | 4 |
| `T_CHAR` | 5 |
| `T_FLOAT` | 6 |
| `T_DOUBLE` | 7 |
| `T_BYTE` | 8 |
| `T_SHORT` | 9 |
| `T_INT` | 10 |
| `T_LONG` | 11 |

A new array whose components are of type _atype_ and of length _count_ is allocated from the garbage-collected heap. A `reference` _arrayref_ to this new array object is pushed into the operand stack. Each of the elements of the new array is initialized to the default initial value \([§2.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3), [§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) for the element type of the array type.

**Run-time Exception**

If _count_ is less than zero, _newarray_ throws a `NegativeArraySizeException`.

**Notes**

In Oracle's Java Virtual Machine implementation, arrays of type `boolean` \(_atype_ is `T_BOOLEAN`\) are stored as arrays of 8-bit values and are manipulated using the _baload_ and _bastore_ instructions \([§_baload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.baload), [§_bastore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.bastore)\) which also access arrays of type `byte`. Other implementations may implement packed `boolean` arrays; the _baload_ and _bastore_ instructions must still be used to access those arrays.

#### _nop_

**Operation**

Do nothing

**Format**

  
_nop_  


**Forms**

_nop_ = 0 \(0x0\)

**Operand Stack**

No change

**Description**

Do nothing.

#### _pop_

**Operation**

Pop the top operand stack value

**Format**

  
_pop_  


**Forms**

_pop_ = 87 \(0x57\)

**Operand Stack**

..., _value_ →

...

**Description**

Pop the top value from the operand stack.

The _pop_ instruction must not be used unless _value_ is a value of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

#### _pop2_

**Operation**

Pop the top one or two operand stack values

**Format**

  
_pop2_  


**Forms**

_pop2_ = 88 \(0x58\)

**Operand Stack**

Form 1:

..., _value2_, _value1_ →

...

where each of _value1_ and _value2_ is a value of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 2:

..., _value_ →

...

where _value_ is a value of a category 2 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

**Description**

Pop the top one or two values from the operand stack.

#### _putfield_

**Operation**

Set field in object

**Format**

  
_putfield_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_putfield_ = 181 \(0xb5\)

**Operand Stack**

..., _objectref_, _value_ →

...

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a field \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor of the field as well as a symbolic reference to the class in which the field is to be found. The class of _objectref_ must not be an array. If the field is `protected`, and it is a member of a superclass of the current class, and the field is not declared in the same run-time package \([§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3)\) as the current class, then the class of _objectref_ must be either the current class or a subclass of the current class.

The referenced field is resolved \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\). The type of a _value_ stored by a _putfield_ instruction must be compatible with the descriptor of the referenced field \([§4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2)\). If the field descriptor type is `boolean`, `byte`, `char`, `short`, or `int`, then the _value_ must be an `int`. If the field descriptor type is `float`, `long`, or `double`, then the _value_ must be a `float`, `long`, or `double`, respectively. If the field descriptor type is a reference type, then the _value_ must be of a type that is assignment compatible \(JLS §5.2\) with the field descriptor type. If the field is `final`, it must be declared in the current class, and the instruction must occur in an instance initialization method \(`<init>`\) of the current class \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\).

The _value_ and _objectref_ are popped from the operand stack. The _objectref_ must be of type `reference`. The _value_ undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_', and the referenced field in _objectref_ is set to _value_'.

**Linking Exceptions**

During resolution of the symbolic reference to the field, any of the exceptions pertaining to field resolution \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\) can be thrown.

Otherwise, if the resolved field is a `static` field, _putfield_ throws an `IncompatibleClassChangeError`.

Otherwise, if the field is `final`, it must be declared in the current class, and the instruction must occur in an instance initialization method \(`<init>`\) of the current class. Otherwise, an `IllegalAccessError` is thrown.

**Run-time Exception**

Otherwise, if _objectref_ is `null`, the _putfield_ instruction throws a `NullPointerException`.

#### _putstatic_

**Operation**

Set static field in class

**Format**

  
_putstatic_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_putstatic_ = 179 \(0xb3\)

**Operand Stack**

..., _value_ →

...

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a field \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor of the field as well as a symbolic reference to the class or interface in which the field is to be found. The referenced field is resolved \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\).

On successful resolution of the field, the class or interface that declared the resolved field is initialized \([§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5)\) if that class or interface has not already been initialized.

The type of a _value_ stored by a _putstatic_ instruction must be compatible with the descriptor of the referenced field \([§4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2)\). If the field descriptor type is `boolean`, `byte`, `char`, `short`, or `int`, then the _value_ must be an `int`. If the field descriptor type is `float`, `long`, or `double`, then the _value_ must be a `float`, `long`, or `double`, respectively. If the field descriptor type is a reference type, then the _value_ must be of a type that is assignment compatible \(JLS §5.2\) with the field descriptor type. If the field is `final`, it must be declared in the current class, and the instruction must occur in the `<clinit>` method of the current class \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\).

The _value_ is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The class field is set to _value_'.

**Linking Exceptions**

During resolution of the symbolic reference to the class or interface field, any of the exceptions pertaining to field resolution \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\) can be thrown.

Otherwise, if the resolved field is not a `static` \(class\) field or an interface field, _putstatic_ throws an `IncompatibleClassChangeError`.

Otherwise, if the field is `final`, it must be declared in the current class, and the instruction must occur in the `<clinit>` method of the current class. Otherwise, an `IllegalAccessError` is thrown.

**Run-time Exception**

Otherwise, if execution of this _putstatic_ instruction causes initialization of the referenced class or interface, _putstatic_ may throw an `Error` as detailed in [§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5).

**Notes**

A _putstatic_ instruction may be used only to set the value of an interface field on the initialization of that field. Interface fields may be assigned to only once, on execution of an interface variable initialization expression when the interface is initialized \([§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5), JLS §9.3.1\).

#### _ret_

**Operation**

Return from subroutine

**Format**

  
_ret_  
_index_  


**Forms**

_ret_ = 169 \(0xa9\)

**Operand Stack**

No change

**Description**

The _index_ is an unsigned byte between 0 and 255, inclusive. The local variable at _index_ in the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) must contain a value of type `returnAddress`. The contents of the local variable are written into the Java Virtual Machine's `pc` register, and execution continues there.

**Notes**

Note that _jsr_ \([§_jsr_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.jsr)\) pushes the address onto the operand stack and _ret_ gets it out of a local variable. This asymmetry is intentional.

In Oracle's implementation of a compiler for the Java programming language prior to Java SE 6, the _ret_ instruction was used with the _jsr_ and _jsr\_w_ instructions \([§_jsr_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.jsr), [§_jsr\_w_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.jsr_w)\) in the implementation of the `finally` clause \([§3.13](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.13), [§4.10.2.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.2.5)\).

The _ret_ instruction should not be confused with the _return_ instruction \([§_return_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.return)\). A _return_ instruction returns control from a method to its invoker, without passing any value back to the invoker.

The _ret_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _return_

**Operation**

Return `void` from method

**Format**

  
_return_  


**Forms**

_return_ = 177 \(0xb1\)

**Operand Stack**

... →

\[empty\]

**Description**

The current method must have return type `void`. If the current method is a `synchronized` method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread. If no exception is thrown, any values on the operand stack of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) are discarded.

The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.

**Run-time Exceptions**

If the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the current method is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _return_ throws an `IllegalMonitorStateException`. This can happen, for example, if a `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is `synchronized`.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _return_ throws an `IllegalMonitorStateException`.

#### _saload_

**Operation**

Load `short` from array

**Format**

  
_saload_  


**Forms**

_saload_ = 53 \(0x35\)

**Operand Stack**

..., _arrayref_, _index_ →

..., _value_

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `short`. The _index_ must be of type `int`. Both _arrayref_ and _index_ are popped from the operand stack. The component of the array at _index_ is retrieved and sign-extended to an `int` _value_. That _value_ is pushed onto the operand stack.

**Run-time Exceptions**

If _arrayref_ is `null`, _saload_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _saload_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _sastore_

**Operation**

Store into `short` array

**Format**

  
_sastore_  


**Forms**

_sastore_ = 86 \(0x56\)

**Operand Stack**

..., _arrayref_, _index_, _value_ →

...

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `short`. Both _index_ and _value_ must be of type `int`. The _arrayref_, _index_, and _value_ are popped from the operand stack. The `int` _value_ is truncated to a `short` and stored as the component of the array indexed by _index_.

**Run-time Exceptions**

If _arrayref_ is `null`, _sastore_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _sastore_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _sipush_

**Operation**

Push `short`

**Format**

  
_sipush_  
_byte1_  
_byte2_  


**Forms**

_sipush_ = 17 \(0x11\)

**Operand Stack**

... →

..., _value_

**Description**

The immediate unsigned _byte1_ and _byte2_ values are assembled into an intermediate `short`, where the value of the `short` is \(_byte1_ `<<` 8\) \| _byte2_. The intermediate value is then sign-extended to an `int` _value_. That _value_ is pushed onto the operand stack.

#### _swap_

**Operation**

Swap the top two operand stack values

**Format**

  
_swap_  


**Forms**

_swap_ = 95 \(0x5f\)

**Operand Stack**

..., _value2_, _value1_ →

..., _value1_, _value2_

**Description**

Swap the top two values on the operand stack.

The _swap_ instruction must not be used unless _value1_ and _value2_ are both values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

**Notes**

The Java Virtual Machine does not provide an instruction implementing a swap on operands of category 2 computational types.

#### _tableswitch_

**Operation**

Access jump table by index and jump

**Format**

  
_tableswitch_  
_&lt;0-3 byte pad&gt;_  
_defaultbyte1_  
_defaultbyte2_  
_defaultbyte3_  
_defaultbyte4_  
_lowbyte1_  
_lowbyte2_  
_lowbyte3_  
_lowbyte4_  
_highbyte1_  
_highbyte2_  
_highbyte3_  
_highbyte4_  
_jump offsets..._  


**Forms**

_tableswitch_ = 170 \(0xaa\)

**Operand Stack**

..., _index_ →

...

**Description**

A _tableswitch_ is a variable-length instruction. Immediately after the _tableswitch_ opcode, between zero and three bytes must act as padding, such that _defaultbyte1_ begins at an address that is a multiple of four bytes from the start of the current method \(the opcode of its first instruction\). Immediately after the padding are bytes constituting three signed 32-bit values: _default_, _low_, and _high_. Immediately following are bytes constituting a series of _high_ - _low_ + 1 signed 32-bit offsets. The value _low_ must be less than or equal to _high_. The _high_ - _low_ + 1 signed 32-bit offsets are treated as a 0-based jump table. Each of these signed 32-bit values is constructed as \(_byte1_ `<<` 24\) \| \(_byte2_ `<<` 16\) \| \(_byte3_ `<<` 8\) \| _byte4_.

The _index_ must be of type `int` and is popped from the operand stack. If _index_ is less than _low_ or _index_ is greater than _high_, then a target address is calculated by adding _default_ to the address of the opcode of this _tableswitch_ instruction. Otherwise, the offset at position _index_ - _low_ of the jump table is extracted. The target address is calculated by adding that offset to the address of the opcode of this _tableswitch_ instruction. Execution then continues at the target address.

The target address that can be calculated from each jump table offset, as well as the one that can be calculated from _default_, must be the address of an opcode of an instruction within the method that contains this _tableswitch_ instruction.

**Notes**

The alignment required of the 4-byte operands of the _tableswitch_ instruction guarantees 4-byte alignment of those operands if and only if the method that contains the _tableswitch_ starts on a 4-byte boundary.

#### _wide_

**Operation**

Extend local variable index by additional bytes

**Format 1**

  
_wide_  
_&lt;opcode&gt;_  
_indexbyte1_  
_indexbyte2_  


where _&lt;opcode&gt;_ is one of _iload_, _fload_, _aload_, _lload_, _dload_, _istore_, _fstore_, _astore_, _lstore_, _dstore_, or _ret_

**Format 2**

  
_wide_  
_iinc_  
_indexbyte1_  
_indexbyte2_  
_constbyte1_  
_constbyte2_  


**Forms**

_wide_ = 196 \(0xc4\)

**Operand Stack**

Same as modified instruction

**Description**

The _wide_ instruction modifies the behavior of another instruction. It takes one of two formats, depending on the instruction being modified. The first form of the _wide_ instruction modifies one of the instructions _iload_, _fload_, _aload_, _lload_, _dload_, _istore_, _fstore_, _astore_, _lstore_, _dstore_, or _ret_ \([§_iload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iload), [§_fload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.fload), [§_aload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload), [§_lload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.lload), [§_dload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dload), [§_istore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.istore), [§_fstore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.fstore), [§_astore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.astore), [§_lstore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.lstore), [§_dstore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dstore), [§_ret_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ret)\). The second form applies only to the _iinc_ instruction \([§_iinc_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iinc)\).

In either case, the _wide_ opcode itself is followed in the compiled code by the opcode of the instruction _wide_ modifies. In either form, two unsigned bytes _indexbyte1_ and _indexbyte2_ follow the modified opcode and are assembled into a 16-bit unsigned index to a local variable in the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The calculated index must be an index into the local variable array of the current frame. Where the _wide_ instruction modifies an _lload_, _dload_, _lstore_, or _dstore_ instruction, the index following the calculated index \(index + 1\) must also be an index into the local variable array. In the second form, two immediate unsigned bytes _constbyte1_ and _constbyte2_ follow _indexbyte1_ and _indexbyte2_ in the code stream. Those bytes are also assembled into a signed 16-bit constant, where the constant is \(_constbyte1_ `<<` 8\) \| _constbyte2_.

The widened bytecode operates as normal, except for the use of the wider index and, in the case of the second form, the larger increment range.

**Notes**

Although we say that _wide_ "modifies the behavior of another instruction," the _wide_ instruction effectively treats the bytes constituting the modified instruction as operands, denaturing the embedded instruction in the process. In the case of a modified _iinc_ instruction, one of the logical operands of the _iinc_ is not even at the normal offset from the opcode. The embedded instruction must never be executed directly; its opcode must never be the target of any control transfer instruction.

