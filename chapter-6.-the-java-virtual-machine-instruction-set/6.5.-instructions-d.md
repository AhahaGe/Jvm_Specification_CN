# 6.5. Instructions \(d\)

#### _d2f_

**Operation**

Convert `double` to `float`

**Format**

  
_d2f_  


**Forms**

_d2f_ = 144 \(0x90\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `double`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) resulting in _value_'. Then _value_' is converted to a `float` result using IEEE 754 round to nearest mode. The _result_ is pushed onto the operand stack.

Where an _d2f_ instruction is FP-strict \([§2.8.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.2)\), the result of the conversion is always rounded to the nearest representable value in the float value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\).

Where an _d2f_ instruction is not FP-strict, the result of the conversion may be taken from the float-extended-exponent value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\); it is not necessarily rounded to the nearest representable value in the float value set.

A finite _value_' too small to be represented as a `float` is converted to a zero of the same sign; a finite _value_' too large to be represented as a `float` is converted to an infinity of the same sign. A `double` NaN is converted to a `float` NaN.

**Notes**

The _d2f_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_' and may also lose precision.

#### _d2i_

**Operation**

Convert `double` to `int`

**Format**

  
_d2i_  


**Forms**

_d2i_ = 142 \(0x8e\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `double`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) resulting in _value_'. Then _value_' is converted to an `int`. The result is pushed onto the operand stack:

* If the _value_' is NaN, the _result_ of the conversion is an `int` 0.
* Otherwise, if the _value_' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as an `int`, then the result is the `int` value V.
* Otherwise, either the _value_' must be too small \(a negative value of large magnitude or negative infinity\), and the _result_ is the smallest representable value of type `int`, or the _value_' must be too large \(a positive value of large magnitude or positive infinity\), and the _result_ is the largest representable value of type `int`.

**Notes**

The _d2i_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_' and may also lose precision.

#### _d2l_

**Operation**

Convert `double` to `long`

**Format**

  
_d2l_  


**Forms**

_d2l_ = 143 \(0x8f\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `double`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) resulting in _value_'. Then _value_' is converted to a `long`. The _result_ is pushed onto the operand stack:

* If the _value_' is NaN, the _result_ of the conversion is a `long` 0.
* Otherwise, if the _value_' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as a `long`, then the _result_ is the `long` value V.
* Otherwise, either the _value_' must be too small \(a negative value of large magnitude or negative infinity\), and the _result_ is the smallest representable value of type `long`, or the _value_' must be too large \(a positive value of large magnitude or positive infinity\), and the _result_ is the largest representable value of type `long`.

**Notes**

The _d2l_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_' and may also lose precision.

#### _dadd_

**Operation**

Add `double`

**Format**

  
_dadd_  


**Forms**

_dadd_ = 99 \(0x63\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `double`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `double` _result_ is _value1_' + _value2_'. The _result_ is pushed onto the operand stack.

The result of a _dadd_ instruction is governed by the rules of IEEE arithmetic:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* The sum of two infinities of opposite sign is NaN.
* The sum of two infinities of the same sign is the infinity of that sign.
* The sum of an infinity and any finite value is equal to the infinity.
* The sum of two zeroes of opposite sign is positive zero.
* The sum of two zeroes of the same sign is the zero of that sign.
* The sum of a zero and a nonzero finite value is equal to the nonzero value.
* The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
* In the remaining cases, where neither operand is an infinity, a zero, or NaN and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a `double`, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a `double`, we say the operation underflows; the result is then a zero of appropriate sign.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of a _dadd_ instruction never throws a run-time exception.

#### _daload_

**Operation**

Load `double` from array

**Format**

  
_daload_  


**Forms**

_daload_ = 49 \(0x31\)

**Operand Stack**

..., _arrayref_, _index_ →

..., _value_

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `double`. The _index_ must be of type `int`. Both _arrayref_ and _index_ are popped from the operand stack. The `double` value in the component of the array at _index_ is retrieved and pushed onto the operand stack.

**Run-time Exceptions**

If _arrayref_ is `null`, _daload_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _daload_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _dastore_

**Operation**

Store into `double` array

**Format**

  
_dastore_  


**Forms**

_dastore_ = 82 \(0x52\)

**Operand Stack**

..., _arrayref_, _index_, _value_ →

...

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `double`. The _index_ must be of type `int`, and value must be of type `double`. The _arrayref_, _index_, and _value_ are popped from the operand stack. The `double` _value_ undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_', which is stored as the component of the array indexed by _index_.

**Run-time Exceptions**

If _arrayref_ is `null`, _dastore_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _dastore_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _dcmp&lt;op&gt;_

**Operation**

Compare `double`

**Format**

  
_dcmp&lt;op&gt;_  


**Forms**

_dcmpg_ = 152 \(0x98\)

_dcmpl_ = 151 \(0x97\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `double`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. A floating-point comparison is performed:

* If _value1_' is greater than _value2_', the `int` value 1 is pushed onto the operand stack.
* Otherwise, if _value1_' is equal to _value2_', the `int` value 0 is pushed onto the operand stack.
* Otherwise, if _value1_' is less than _value2_', the `int` value -1 is pushed onto the operand stack.
* Otherwise, at least one of _value1_' or _value2_' is NaN. The _dcmpg_ instruction pushes the `int` value 1 onto the operand stack and the _dcmpl_ instruction pushes the `int` value -1 onto the operand stack.

Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.

**Notes**

The _dcmpg_ and _dcmpl_ instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any `double` comparison fails if either or both of its operands are NaN. With both _dcmpg_ and _dcmpl_ available, any `double` comparison may be compiled to push the same _result_ onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN. For more information, see [§3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.5).

#### _dconst\_&lt;d&gt;_

**Operation**

Push `double`

**Format**

  
_dconst\_&lt;d&gt;_  


**Forms**

_dconst\_0_ = 14 \(0xe\)

_dconst\_1_ = 15 \(0xf\)

**Operand Stack**

... →

..., &lt;_d_&gt;

**Description**

Push the `double` constant &lt;_d_&gt; \(0.0 or 1.0\) onto the operand stack.

#### _ddiv_

**Operation**

Divide `double`

**Format**

  
_ddiv_  


**Forms**

_ddiv_ = 111 \(0x6f\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `double`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `double` _result_ is _value1_' / _value2_'. The _result_ is pushed onto the operand stack.

The result of a _ddiv_ instruction is governed by the rules of IEEE arithmetic:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* If neither _value1_' nor _value2_' is NaN, the sign of the result is positive if both values have the same sign, negative if the values have different signs.
* Division of an infinity by an infinity results in NaN.
* Division of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.
* Division of a finite value by an infinity results in a signed zero, with the sign-producing rule just given.
* Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero, with the sign-producing rule just given.
* Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.
* In the remaining cases, where neither operand is an infinity, a zero, or NaN, the quotient is computed and rounded to the nearest `double` using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a `double`, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a `double`, we say the operation underflows; the result is then a zero of appropriate sign.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of a _ddiv_ instruction never throws a run-time exception.

#### _dload_

**Operation**

Load `double` from local variable

**Format**

  
_dload_  
_index_  


**Forms**

_dload_ = 24 \(0x18\)

**Operand Stack**

... →

..., _value_

**Description**

The _index_ is an unsigned byte. Both _index_ and _index_+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at _index_ must contain a `double`. The _value_ of the local variable at _index_ is pushed onto the operand stack.

**Notes**

The _dload_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _dload\_&lt;n&gt;_

**Operation**

Load `double` from local variable

**Format**

  
_dload\_&lt;n&gt;_  


**Forms**

_dload\_0_ = 38 \(0x26\)

_dload\_1_ = 39 \(0x27\)

_dload\_2_ = 40 \(0x28\)

_dload\_3_ = 41 \(0x29\)

**Operand Stack**

... →

..., _value_

**Description**

Both &lt;_n_&gt; and &lt;_n_&gt;+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at &lt;_n_&gt; must contain a `double`. The _value_ of the local variable at &lt;_n_&gt; is pushed onto the operand stack.

**Notes**

Each of the _dload\_&lt;n&gt;_ instructions is the same as _dload_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _dmul_

**Operation**

Multiply `double`

**Format**

  
_dmul_  


**Forms**

_dmul_ = 107 \(0x6b\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `double`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `double` result is _value1_' \* _value2_'. The _result_ is pushed onto the operand stack.

The result of a _dmul_ instruction is governed by the rules of IEEE arithmetic:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* If neither _value1_' nor _value2_' is NaN, the sign of the result is positive if both values have the same sign and negative if the values have different signs.
* Multiplication of an infinity by a zero results in NaN.
* Multiplication of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.
* In the remaining cases, where neither an infinity nor NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a `double`, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a `double`, we say the operation underflows; the result is then a zero of appropriate sign.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of a _dmul_ instruction never throws a run-time exception.

#### _dneg_

**Operation**

Negate `double`

**Format**

  
_dneg_  


**Forms**

_dneg_ = 119 \(0x77\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The value must be of type `double`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The `double` _result_ is the arithmetic negation of _value_'. The _result_ is pushed onto the operand stack.

For `double` values, negation is not the same as subtraction from zero. If `x` is `+0.0`, then `0.0-x` equals `+0.0`, but `-x` equals `-0.0`. Unary minus merely inverts the sign of a `double`.

Special cases of interest:

* If the operand is NaN, the result is NaN \(recall that NaN has no sign\).
* If the operand is an infinity, the result is the infinity of opposite sign.
* If the operand is a zero, the result is the zero of opposite sign.

#### _drem_

**Operation**

Remainder `double`

**Format**

  
_drem_  


**Forms**

_drem_ = 115 \(0x73\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `double`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The _result_ is calculated and pushed onto the operand stack as a `double`.

The result of a _drem_ instruction is not the same as that of the so-called remainder operation defined by IEEE 754. The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is _not_ analogous to that of the usual integer remainder operator. Instead, the Java Virtual Machine defines _drem_ to behave in a manner analogous to that of the Java Virtual Machine integer remainder instructions \(_irem_ and _lrem_\); this may be compared with the C library function `fmod`.

The result of a _drem_ instruction is governed by these rules:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* If neither _value1_' nor _value2_' is NaN, the sign of the result equals the sign of the dividend.
* If the dividend is an infinity or the divisor is a zero or both, the result is NaN.
* If the dividend is finite and the divisor is an infinity, the result equals the dividend.
* If the dividend is a zero and the divisor is finite, the result equals the dividend.
* In the remaining cases, where neither operand is an infinity, a zero, or NaN, the floating-point remainder _result_ from a dividend _value1_' and a divisor _value2_' is defined by the mathematical relation _result_ = _value1_' - \(_value2_' \* _q_\), where _q_ is an integer that is negative only if _value1_' / _value2_' is negative, and positive only if _value1_' / _value2_' is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of _value1_' and _value2_'.

Despite the fact that division by zero may occur, evaluation of a _drem_ instruction never throws a run-time exception. Overflow, underflow, or loss of precision cannot occur.

**Notes**

The IEEE 754 remainder operation may be computed by the library routine `Math.IEEEremainder`.

#### _dreturn_

**Operation**

Return `double` from method

**Format**

  
_dreturn_  


**Forms**

_dreturn_ = 175 \(0xaf\)

**Operand Stack**

..., _value_ →

\[empty\]

**Description**

The current method must have return type `double`. The _value_ must be of type `double`. If the current method is a `synchronized` method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread. If no exception is thrown, _value_ is popped from the operand stack of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The _value_' is pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.

The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.

**Run-time Exceptions**

If the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the current method is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _dreturn_ throws an `IllegalMonitorStateException`. This can happen, for example, if a `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is synchronized.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _dreturn_ throws an `IllegalMonitorStateException`.

#### _dstore_

**Operation**

Store `double` into local variable

**Format**

  
_dstore_  
_index_  


**Forms**

_dstore_ = 57 \(0x39\)

**Operand Stack**

..., _value_ →

...

**Description**

The _index_ is an unsigned byte. Both _index_ and _index_+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `double`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The local variables at _index_ and _index_+1 are set to _value_'.

**Notes**

The _dstore_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _dstore\_&lt;n&gt;_

**Operation**

Store `double` into local variable

**Format**

  
_dstore\_&lt;n&gt;_  


**Forms**

_dstore\_0_ = 71 \(0x47\)

_dstore\_1_ = 72 \(0x48\)

_dstore\_2_ = 73 \(0x49\)

_dstore\_3_ = 74 \(0x4a\)

**Operand Stack**

..., _value_ →

...

**Description**

Both &lt;_n_&gt; and &lt;_n_&gt;+1 must be indices into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `double`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The local variables at &lt;_n_&gt; and &lt;_n_&gt;+1 are set to _value_'.

**Notes**

Each of the _dstore\_&lt;n&gt;_ instructions is the same as _dstore_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _dsub_

**Operation**

Subtract `double`

**Format**

  
_dsub_  


**Forms**

_dsub_ = 103 \(0x67\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `double`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `double` _result_ is _value1_' - _value2_'. The _result_ is pushed onto the operand stack.

For `double` subtraction, it is always the case that `a-b` produces the same result as `a+(-b)`. However, for the _dsub_ instruction, subtraction from zero is not the same as negation, because if `x` is `+0.0`, then `0.0-x` equals `+0.0`, but `-x` equals `-0.0`.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of a _dsub_ instruction never throws a run-time exception.

#### _dup_

**Operation**

Duplicate the top operand stack value

**Format**

  
_dup_  


**Forms**

_dup_ = 89 \(0x59\)

**Operand Stack**

..., _value_ →

..., _value_, _value_

**Description**

Duplicate the top value on the operand stack and push the duplicated value onto the operand stack.

The _dup_ instruction must not be used unless _value_ is a value of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

#### _dup\_x1_

**Operation**

Duplicate the top operand stack value and insert two values down

**Format**

  
_dup\_x1_  


**Forms**

_dup\_x1_ = 90 \(0x5a\)

**Operand Stack**

..., _value2_, _value1_ →

..., _value1_, _value2_, _value1_

**Description**

Duplicate the top value on the operand stack and insert the duplicated value two values down in the operand stack.

The _dup\_x1_ instruction must not be used unless both _value1_ and _value2_ are values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

#### _dup\_x2_

**Operation**

Duplicate the top operand stack value and insert two or three values down

**Format**

  
_dup\_x2_  


**Forms**

_dup\_x2_ = 91 \(0x5b\)

**Operand Stack**

Form 1:

..., _value3_, _value2_, _value1_ →

..., _value1_, _value3_, _value2_, _value1_

where _value1_, _value2_, and _value3_ are all values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 2:

..., _value2_, _value1_ →

..., _value1_, _value2_, _value1_

where _value1_ is a value of a category 1 computational type and _value2_ is a value of a category 2 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

**Description**

Duplicate the top value on the operand stack and insert the duplicated value two or three values down in the operand stack.

#### _dup2_

**Operation**

Duplicate the top one or two operand stack values

**Format**

  
_dup2_  


**Forms**

_dup2_ = 92 \(0x5c\)

**Operand Stack**

Form 1:

..., _value2_, _value1_ →

..., _value2_, _value1_, _value2_, _value1_

where both _value1_ and _value2_ are values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 2:

..., _value_ →

..., _value_, _value_

where _value_ is a value of a category 2 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

**Description**

Duplicate the top one or two values on the operand stack and push the duplicated value or values back onto the operand stack in the original order.

#### _dup2\_x1_

**Operation**

Duplicate the top one or two operand stack values and insert two or three values down

**Format**

  
_dup2\_x1_  


**Forms**

_dup2\_x1_ = 93 \(0x5d\)

**Operand Stack**

Form 1:

..., _value3_, _value2_, _value1_ →

..., _value2_, _value1_, _value3_, _value2_, _value1_

where _value1_, _value2_, and _value3_ are all values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 2:

..., _value2_, _value1_ →

..., _value1_, _value2_, _value1_

where _value1_ is a value of a category 2 computational type and _value2_ is a value of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

**Description**

Duplicate the top one or two values on the operand stack and insert the duplicated values, in the original order, one value beneath the original value or values in the operand stack.

#### _dup2\_x2_

**Operation**

Duplicate the top one or two operand stack values and insert two, three, or four values down

**Format**

  
_dup2\_x2_  


**Forms**

_dup2\_x2_ = 94 \(0x5e\)

**Operand Stack**

Form 1:

..., _value4_, _value3_, _value2_, _value1_ →

..., _value2_, _value1_, _value4_, _value3_, _value2_, _value1_

where _value1_, _value2_, _value3_, and _value4_ are all values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 2:

..., _value3_, _value2_, _value1_ →

..., _value1_, _value3_, _value2_, _value1_

where _value1_ is a value of a category 2 computational type and _value2_ and _value3_ are both values of a category 1 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 3:

..., _value3_, _value2_, _value1_ →

..., _value2_, _value1_, _value3_, _value2_, _value1_

where _value1_ and _value2_ are both values of a category 1 computational type and _value3_ is a value of a category 2 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

Form 4:

..., _value2_, _value1_ →

..., _value1_, _value2_, _value1_

where _value1_ and _value2_ are both values of a category 2 computational type \([§2.11.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)\).

**Description**

Duplicate the top one or two values on the operand stack and insert the duplicated values, in the original order, into the operand stack.

