# 6.5. Instructions \(f-invokeVirtual\)

#### _f2d_

**Operation**

Convert `float` to `double`

**Format**

  
_f2d_  


**Forms**

_f2d_ = 141 \(0x8d\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `float`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. Then _value_' is converted to a `double` _result_. This _result_ is pushed onto the operand stack.

**Notes**

Where an _f2d_ instruction is FP-strict \([§2.8.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.2)\) it performs a widening primitive conversion \(JLS §5.1.2\). Because all values of the float value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\) are exactly representable by values of the double value set \([§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\), such a conversion is exact.

Where an _f2d_ instruction is not FP-strict, the result of the conversion may be taken from the double-extended-exponent value set; it is not necessarily rounded to the nearest representable value in the double value set. However, if the operand _value_ is taken from the float-extended-exponent value set and the target result is constrained to the double value set, rounding of _value_ may be required.

#### _f2i_

**Operation**

Convert `float` to `int`

**Format**

  
_f2i_  


**Forms**

_f2i_ = 139 \(0x8b\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `float`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. Then _value_' is converted to an `int` _result_. This _result_ is pushed onto the operand stack:

* If the _value_' is NaN, the _result_ of the conversion is an `int` 0.
* Otherwise, if the _value_' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as an `int`, then the _result_ is the `int` value V.
* Otherwise, either the _value_' must be too small \(a negative value of large magnitude or negative infinity\), and the _result_ is the smallest representable value of type `int`, or the _value_' must be too large \(a positive value of large magnitude or positive infinity\), and the _result_ is the largest representable value of type `int`.

**Notes**

The _f2i_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_' and may also lose precision.

#### _f2l_

**Operation**

Convert `float` to `long`

**Format**

  
_f2l_  


**Forms**

_f2l_ = 140 \(0x8c\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `float`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. Then _value_' is converted to a `long` _result_. This _result_ is pushed onto the operand stack:

* If the _value_' is NaN, the result of the conversion is a `long` 0.
* Otherwise, if the _value_' is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as a `long`, then the _result_ is the `long` value V.
* Otherwise, either the _value_' must be too small \(a negative value of large magnitude or negative infinity\), and the _result_ is the smallest representable value of type `long`, or the _value_' must be too large \(a positive value of large magnitude or positive infinity\), and the _result_ is the largest representable value of type `long`.

**Notes**

The _f2l_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_' and may also lose precision.

#### _fadd_

**Operation**

Add `float`

**Format**

  
_fadd_  


**Forms**

_fadd_ = 98 \(0x62\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `float`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `float` _result_ is _value1_' + _value2_'. The _result_ is pushed onto the operand stack.

The result of an _fadd_ instruction is governed by the rules of IEEE arithmetic:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* The sum of two infinities of opposite sign is NaN.
* The sum of two infinities of the same sign is the infinity of that sign.
* The sum of an infinity and any finite value is equal to the infinity.
* The sum of two zeroes of opposite sign is positive zero.
* The sum of two zeroes of the same sign is the zero of that sign.
* The sum of a zero and a nonzero finite value is equal to the nonzero value.
* The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
* In the remaining cases, where neither operand is an infinity, a zero, or NaN and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a `float`, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a `float`, we say the operation underflows; the result is then a zero of appropriate sign.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an _fadd_ instruction never throws a run-time exception.

#### _faload_

**Operation**

Load `float` from array

**Format**

  
_faload_  


**Forms**

_faload_ = 48 \(0x30\)

**Operand Stack**

..., _arrayref_, _index_ →

..., _value_

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `float`. The _index_ must be of type `int`. Both _arrayref_ and _index_ are popped from the operand stack. The `float` value in the component of the array at _index_ is retrieved and pushed onto the operand stack.

**Run-time Exceptions**

If _arrayref_ is `null`, _faload_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _faload_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _fastore_

**Operation**

Store into `float` array

**Format**

  
_fastore_  


**Forms**

_fastore_ = 81 \(0x51\)

**Operand Stack**

..., _arrayref_, _index_, _value_ →

...

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `float`. The _index_ must be of type `int`, and the _value_ must be of type `float`. The _arrayref_, _index_, and _value_ are popped from the operand stack. The `float` _value_ undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_', and _value_' is stored as the component of the array indexed by _index_.

**Run-time Exceptions**

If _arrayref_ is `null`, _fastore_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _fastore_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _fcmp&lt;op&gt;_

**Operation**

Compare `float`

**Format**

  
_fcmp&lt;op&gt;_  


**Forms**

_fcmpg_ = 150 \(0x96\)

_fcmpl_ = 149 \(0x95\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `float`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. A floating-point comparison is performed:

* If _value1_' is greater than _value2_', the `int` value 1 is pushed onto the operand stack.
* Otherwise, if _value1_' is equal to _value2_', the `int` value 0 is pushed onto the operand stack.
* Otherwise, if _value1_' is less than _value2_', the `int` value -1 is pushed onto the operand stack.
* Otherwise, at least one of _value1_' or _value2_' is NaN. The _fcmpg_ instruction pushes the `int` value 1 onto the operand stack and the _fcmpl_ instruction pushes the `int` value -1 onto the operand stack.

Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.

**Notes**

The _fcmpg_ and _fcmpl_ instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any `float` comparison fails if either or both of its operands are NaN. With both _fcmpg_ and _fcmpl_ available, any `float` comparison may be compiled to push the same _result_ onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN. For more information, see [§3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.5).

#### _fconst\_&lt;f&gt;_

**Operation**

Push `float`

**Format**

  
_fconst\_&lt;f&gt;_  


**Forms**

_fconst\_0_ = 11 \(0xb\)

_fconst\_1_ = 12 \(0xc\)

_fconst\_2_ = 13 \(0xd\)

**Operand Stack**

... →

..., &lt;_f_&gt;

**Description**

Push the `float` constant &lt;_f_&gt; \(0.0, 1.0, or 2.0\) onto the operand stack.

#### _fdiv_

**Operation**

Divide `float`

**Format**

  
_fdiv_  


**Forms**

_fdiv_ = 110 \(0x6e\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `float`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `float` _result_ is _value1_' / _value2_'. The _result_ is pushed onto the operand stack.

The result of an _fdiv_ instruction is governed by the rules of IEEE arithmetic:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* If neither _value1_' nor _value2_' is NaN, the sign of the result is positive if both values have the same sign, negative if the values have different signs.
* Division of an infinity by an infinity results in NaN.
* Division of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.
* Division of a finite value by an infinity results in a signed zero, with the sign-producing rule just given.
* Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero, with the sign-producing rule just given.
* Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.
* In the remaining cases, where neither operand is an infinity, a zero, or NaN, the quotient is computed and rounded to the nearest `float` using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a `float`, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a `float`, we say the operation underflows; the result is then a zero of appropriate sign.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of an _fdiv_ instruction never throws a run-time exception.

#### _fload_

**Operation**

Load `float` from local variable

**Format**

  
_fload_  
_index_  


**Forms**

_fload_ = 23 \(0x17\)

**Operand Stack**

... →

..., _value_

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at _index_ must contain a `float`. The _value_ of the local variable at _index_ is pushed onto the operand stack.

**Notes**

The _fload_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _fload\_&lt;n&gt;_

**Operation**

Load `float` from local variable

**Format**

  
_fload\_&lt;n&gt;_  


**Forms**

_fload\_0_ = 34 \(0x22\)

_fload\_1_ = 35 \(0x23\)

_fload\_2_ = 36 \(0x24\)

_fload\_3_ = 37 \(0x25\)

**Operand Stack**

... →

..., _value_

**Description**

The &lt;_n_&gt; must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at &lt;_n_&gt; must contain a `float`. The _value_ of the local variable at &lt;_n_&gt; is pushed onto the operand stack.

**Notes**

Each of the _fload\_&lt;n&gt;_ instructions is the same as _fload_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _fmul_

**Operation**

Multiply `float`

**Format**

  
_fmul_  


**Forms**

_fmul_ = 106 \(0x6a\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `float`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `float` _result_ is _value1_' \* _value2_'. The _result_ is pushed onto the operand stack.

The result of an _fmul_ instruction is governed by the rules of IEEE arithmetic:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* If neither _value1_' nor _value2_' is NaN, the sign of the result is positive if both values have the same sign, and negative if the values have different signs.
* Multiplication of an infinity by a zero results in NaN.
* Multiplication of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.
* In the remaining cases, where neither an infinity nor NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a `float`, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a `float`, we say the operation underflows; the result is then a zero of appropriate sign.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an _fmul_ instruction never throws a run-time exception.

#### _fneg_

**Operation**

Negate `float`

**Format**

  
_fneg_  


**Forms**

_fneg_ = 118 \(0x76\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ must be of type `float`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The `float` _result_ is the arithmetic negation of _value_'. This _result_ is pushed onto the operand stack.

For `float` values, negation is not the same as subtraction from zero. If `x` is `+0.0`, then `0.0-x` equals `+0.0`, but `-x` equals `-0.0`. Unary minus merely inverts the sign of a `float`.

Special cases of interest:

* If the operand is NaN, the result is NaN \(recall that NaN has no sign\).
* If the operand is an infinity, the result is the infinity of opposite sign.
* If the operand is a zero, the result is the zero of opposite sign.

#### _frem_

**Operation**

Remainder `float`

**Format**

  
_frem_  


**Forms**

_frem_ = 114 \(0x72\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `float`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The _result_ is calculated and pushed onto the operand stack as a `float`.

The _result_ of an _frem_ instruction is not the same as that of the so-called remainder operation defined by IEEE 754. The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is _not_ analogous to that of the usual integer remainder operator. Instead, the Java Virtual Machine defines _frem_ to behave in a manner analogous to that of the Java Virtual Machine integer remainder instructions \(_irem_ and _lrem_\); this may be compared with the C library function `fmod`.

The result of an _frem_ instruction is governed by these rules:

* If either _value1_' or _value2_' is NaN, the result is NaN.
* If neither _value1_' nor _value2_' is NaN, the sign of the result equals the sign of the dividend.
* If the dividend is an infinity or the divisor is a zero or both, the result is NaN.
* If the dividend is finite and the divisor is an infinity, the result equals the dividend.
* If the dividend is a zero and the divisor is finite, the result equals the dividend.
* In the remaining cases, where neither operand is an infinity, a zero, or NaN, the floating-point remainder _result_ from a dividend _value1_' and a divisor _value2_' is defined by the mathematical relation _result_ = _value1_' - \(_value2_' \* _q_\), where _q_ is an integer that is negative only if _value1_' / _value2_' is negative and positive only if _value1_' / _value2_' is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of _value1_' and _value2_'.

Despite the fact that division by zero may occur, evaluation of an _frem_ instruction never throws a run-time exception. Overflow, underflow, or loss of precision cannot occur.

**Notes**

The IEEE 754 remainder operation may be computed by the library routine `Math.IEEEremainder`.

#### _freturn_

**Operation**

Return `float` from method

**Format**

  
_freturn_  


**Forms**

_freturn_ = 174 \(0xae\)

**Operand Stack**

..., _value_ →

\[empty\]

**Description**

The current method must have return type `float`. The _value_ must be of type `float`. If the current method is a `synchronized` method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread. If no exception is thrown, _value_ is popped from the operand stack of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The _value_' is pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.

The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.

**Run-time Exceptions**

If the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the current method is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _freturn_ throws an `IllegalMonitorStateException`. This can happen, for example, if a `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is synchronized.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _freturn_ throws an `IllegalMonitorStateException`.

#### _fstore_

**Operation**

Store `float` into local variable

**Format**

  
_fstore_  
_index_  


**Forms**

_fstore_ = 56 \(0x38\)

**Operand Stack**

..., _value_ →

...

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `float`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The value of the local variable at _index_ is set to _value_'.

**Notes**

The _fstore_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _fstore\_&lt;n&gt;_

**Operation**

Store `float` into local variable

**Format**

  
_fstore\_&lt;n&gt;_  


**Forms**

_fstore\_0_ = 67 \(0x43\)

_fstore\_1_ = 68 \(0x44\)

_fstore\_2_ = 69 \(0x45\)

_fstore\_3_ = 70 \(0x46\)

**Operand Stack**

..., _value_ →

...

**Description**

The &lt;_n_&gt; must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _value_ on the top of the operand stack must be of type `float`. It is popped from the operand stack and undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value_'. The value of the local variable at &lt;_n_&gt; is set to _value_'.

**Notes**

Each of the _fstore\_&lt;n&gt;_ instructions is the same as _fstore_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _fsub_

**Operation**

Subtract `float`

**Format**

  
_fsub_  


**Forms**

_fsub_ = 102 \(0x66\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `float`. The values are popped from the operand stack and undergo value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\), resulting in _value1_' and _value2_'. The `float` _result_ is _value1_' - _value2_'. The _result_ is pushed onto the operand stack.

For `float` subtraction, it is always the case that `a-b` produces the same result as `a+(-b)`. However, for the _fsub_ instruction, subtraction from zero is not the same as negation, because if `x` is `+0.0`, then `0.0-x` equals `+0.0`, but `-x` equals `-0.0`.

The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an _fsub_ instruction never throws a run-time exception.

#### _getfield_

**Operation**

Fetch field from object

**Format**

  
_getfield_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_getfield_ = 180 \(0xb4\)

**Operand Stack**

..., _objectref_ →

..., _value_

**Description**

The _objectref_, which must be of type `reference`, is popped from the operand stack. The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a field \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor of the field as well as a symbolic reference to the class in which the field is to be found. The referenced field is resolved \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\). The _value_ of the referenced field in _objectref_ is fetched and pushed onto the operand stack.

The type of _objectref_ must not be an array type. If the field is `protected`, and it is a member of a superclass of the current class, and the field is not declared in the same run-time package \([§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3)\) as the current class, then the class of _objectref_ must be either the current class or a subclass of the current class.

**Linking Exceptions**

During resolution of the symbolic reference to the field, any of the errors pertaining to field resolution \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\) can be thrown.

Otherwise, if the resolved field is a `static` field, _getfield_ throws an `IncompatibleClassChangeError`.

**Run-time Exception**

Otherwise, if _objectref_ is `null`, the _getfield_ instruction throws a `NullPointerException`.

**Notes**

The _getfield_ instruction cannot be used to access the `length` field of an array. The _arraylength_ instruction \([§_arraylength_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.arraylength)\) is used instead.

#### _getstatic_

**Operation**

Get `static` field from class

**Format**

  
_getstatic_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_getstatic_ = 178 \(0xb2\)

**Operand Stack**

..., →

..., _value_

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a field \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor of the field as well as a symbolic reference to the class or interface in which the field is to be found. The referenced field is resolved \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\).

On successful resolution of the field, the class or interface that declared the resolved field is initialized \([§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5)\) if that class or interface has not already been initialized.

The _value_ of the class or interface field is fetched and pushed onto the operand stack.

**Linking Exceptions**

During resolution of the symbolic reference to the class or interface field, any of the exceptions pertaining to field resolution \([§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2)\) can be thrown.

Otherwise, if the resolved field is not a `static` \(class\) field or an interface field, _getstatic_ throws an `IncompatibleClassChangeError`.

**Run-time Exception**

Otherwise, if execution of this _getstatic_ instruction causes initialization of the referenced class or interface, _getstatic_ may throw an `Error` as detailed in [§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5).

#### _goto_

**Operation**

Branch always

**Format**

  
_goto_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_goto_ = 167 \(0xa7\)

**Operand Stack**

No change

**Description**

The unsigned bytes _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit _branchoffset_, where _branchoffset_ is \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution proceeds at that offset from the address of the opcode of this _goto_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _goto_ instruction.

#### _goto\_w_

**Operation**

Branch always \(wide index\)

**Format**

  
_goto\_w_  
_branchbyte1_  
_branchbyte2_  
_branchbyte3_  
_branchbyte4_  


**Forms**

_goto\_w_ = 200 \(0xc8\)

**Operand Stack**

No change

**Description**

The unsigned bytes _branchbyte1_, _branchbyte2_, _branchbyte3_, and _branchbyte4_ are used to construct a signed 32-bit _branchoffset_, where _branchoffset_ is \(_branchbyte1_ `<<` 24\) \| \(_branchbyte2_ `<<` 16\) \| \(_branchbyte3_ `<<` 8\) \| _branchbyte4_. Execution proceeds at that offset from the address of the opcode of this _goto\_w_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _goto\_w_ instruction.

**Notes**

Although the _goto\_w_ instruction takes a 4-byte branch offset, other factors limit the size of a method to 65535 bytes \([§4.11](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.11)\). This limit may be raised in a future release of the Java Virtual Machine.

#### _i2b_

**Operation**

Convert `int` to `byte`

**Format**

  
_i2b_  


**Forms**

_i2b_ = 145 \(0x91\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack, truncated to a `byte`, then sign-extended to an `int` _result_. That _result_ is pushed onto the operand stack.

**Notes**

The _i2b_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_. The _result_ may also not have the same sign as _value_.

#### _i2c_

**Operation**

Convert `int` to `char`

**Format**

  
_i2c_  


**Forms**

_i2c_ = 146 \(0x92\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack, truncated to `char`, then zero-extended to an `int` _result_. That _result_ is pushed onto the operand stack.

**Notes**

The _i2c_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_. The _result_ \(which is always positive\) may also not have the same sign as _value_.

#### _i2d_

**Operation**

Convert `int` to `double`

**Format**

  
_i2d_  


**Forms**

_i2d_ = 135 \(0x87\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack and converted to a `double` _result_. The _result_ is pushed onto the operand stack.

**Notes**

The _i2d_ instruction performs a widening primitive conversion \(JLS §5.1.2\). Because all values of type `int` are exactly representable by type `double`, the conversion is exact.

#### _i2f_

**Operation**

Convert `int` to `float`

**Format**

  
_i2f_  


**Forms**

_i2f_ = 134 \(0x86\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack and converted to the `float` _result_ using IEEE 754 round to nearest mode. The _result_ is pushed onto the operand stack.

**Notes**

The _i2f_ instruction performs a widening primitive conversion \(JLS §5.1.2\), but may result in a loss of precision because values of type `float` have only 24 significand bits.

#### _i2l_

**Operation**

Convert `int` to `long`

**Format**

  
_i2l_  


**Forms**

_i2l_ = 133 \(0x85\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack and sign-extended to a `long` _result_. That _result_ is pushed onto the operand stack.

**Notes**

The _i2l_ instruction performs a widening primitive conversion \(JLS §5.1.2\). Because all values of type `int` are exactly representable by type `long`, the conversion is exact.

#### _i2s_

**Operation**

Convert `int` to `short`

**Format**

  
_i2s_  


**Forms**

_i2s_ = 147 \(0x93\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ on the top of the operand stack must be of type `int`. It is popped from the operand stack, truncated to a `short`, then sign-extended to an `int` _result_. That _result_ is pushed onto the operand stack.

**Notes**

The _i2s_ instruction performs a narrowing primitive conversion \(JLS §5.1.3\). It may lose information about the overall magnitude of _value_. The _result_ may also not have the same sign as _value_.

#### _iadd_

**Operation**

Add `int`

**Format**

  
_iadd_  


**Forms**

_iadd_ = 96 \(0x60\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. The `int` _result_ is _value1_ + _value2_. The _result_ is pushed onto the operand stack.

The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type `int`. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.

Despite the fact that overflow may occur, execution of an _iadd_ instruction never throws a run-time exception.

#### _iaload_

**Operation**

Load `int` from array

**Format**

  
_iaload_  


**Forms**

_iaload_ = 46 \(0x2e\)

**Operand Stack**

..., _arrayref_, _index_ →

..., _value_

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `int`. The _index_ must be of type `int`. Both _arrayref_ and _index_ are popped from the operand stack. The `int` _value_ in the component of the array at _index_ is retrieved and pushed onto the operand stack.

**Run-time Exceptions**

If _arrayref_ is `null`, _iaload_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _iaload_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _iand_

**Operation**

Boolean AND `int`

**Format**

  
_iand_  


**Forms**

_iand_ = 126 \(0x7e\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. They are popped from the operand stack. An `int` _result_ is calculated by taking the bitwise AND \(conjunction\) of _value1_ and _value2_. The _result_ is pushed onto the operand stack.

#### _iastore_

**Operation**

Store into `int` array

**Format**

  
_iastore_  


**Forms**

_iastore_ = 79 \(0x4f\)

**Operand Stack**

..., _arrayref_, _index_, _value_ →

...

**Description**

The _arrayref_ must be of type `reference` and must refer to an array whose components are of type `int`. Both _index_ and _value_ must be of type `int`. The _arrayref_, _index_, and _value_ are popped from the operand stack. The `int` _value_ is stored as the component of the array indexed by _index_.

**Run-time Exceptions**

If _arrayref_ is `null`, _iastore_ throws a `NullPointerException`.

Otherwise, if _index_ is not within the bounds of the array referenced by _arrayref_, the _iastore_ instruction throws an `ArrayIndexOutOfBoundsException`.

#### _iconst\_&lt;i&gt;_

**Operation**

Push `int` constant

**Format**

  
_iconst\_&lt;i&gt;_  


**Forms**

_iconst\_m1_ = 2 \(0x2\)

_iconst\_0_ = 3 \(0x3\)

_iconst\_1_ = 4 \(0x4\)

_iconst\_2_ = 5 \(0x5\)

_iconst\_3_ = 6 \(0x6\)

_iconst\_4_ = 7 \(0x7\)

_iconst\_5_ = 8 \(0x8\)

**Operand Stack**

... →

..., &lt;_i_&gt;

**Description**

Push the `int` constant &lt;_i_&gt; \(-1, 0, 1, 2, 3, 4 or 5\) onto the operand stack.

**Notes**

Each of this family of instructions is equivalent to _bipush_ &lt;_i_&gt; for the respective value of &lt;_i_&gt;, except that the operand &lt;_i_&gt; is implicit.

#### _idiv_

**Operation**

Divide `int`

**Format**

  
_idiv_  


**Forms**

_idiv_ = 108 \(0x6c\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. The `int` _result_ is the value of the Java programming language expression _value1_ / _value2_. The _result_ is pushed onto the operand stack.

An `int` division rounds towards 0; that is, the quotient produced for `int` values in _n_/_d_ is an `int` value _q_ whose magnitude is as large as possible while satisfying \|_d_ ⋅ _q_\| ≤ \|_n_\|. Moreover, _q_ is positive when \|_n_\| ≥ \|_d_\| and _n_ and _d_ have the same sign, but _q_ is negative when \|_n_\| ≥ \|_d_\| and _n_ and _d_ have opposite signs.

There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the `int` type, and the divisor is -1, then overflow occurs, and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case.

**Run-time Exception**

If the value of the divisor in an `int` division is 0, _idiv_ throws an `ArithmeticException`.

#### _if\_acmp&lt;cond&gt;_

**Operation**

Branch if `reference` comparison succeeds

**Format**

  
_if\_acmp&lt;cond&gt;_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_if\_acmpeq_ = 165 \(0xa5\)

_if\_acmpne_ = 166 \(0xa6\)

**Operand Stack**

..., _value1_, _value2_ →

...

**Description**

Both _value1_ and _value2_ must be of type `reference`. They are both popped from the operand stack and compared. The results of the comparison are as follows:

* _if\_acmpeq_ succeeds if and only if _value1_ = _value2_
* _if\_acmpne_ succeeds if and only if _value1_ ≠ _value2_

If the comparison succeeds, the unsigned _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit offset, where the offset is calculated to be \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution then proceeds at that offset from the address of the opcode of this _if\_acmp&lt;cond&gt;_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _if\_acmp&lt;cond&gt;_ instruction.

Otherwise, if the comparison fails, execution proceeds at the address of the instruction following this _if\_acmp&lt;cond&gt;_ instruction.

#### _if\_icmp&lt;cond&gt;_

**Operation**

Branch if `int` comparison succeeds

**Format**

  
_if\_icmp&lt;cond&gt;_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_if\_icmpeq_ = 159 \(0x9f\)

_if\_icmpne_ = 160 \(0xa0\)

_if\_icmplt_ = 161 \(0xa1\)

_if\_icmpge_ = 162 \(0xa2\)

_if\_icmpgt_ = 163 \(0xa3\)

_if\_icmple_ = 164 \(0xa4\)

**Operand Stack**

..., _value1_, _value2_ →

...

**Description**

Both _value1_ and _value2_ must be of type `int`. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:

* _if\_icmpeq_ succeeds if and only if _value1_ = _value2_
* _if\_icmpne_ succeeds if and only if _value1_ ≠ _value2_
* _if\_icmplt_ succeeds if and only if _value1_ &lt; _value2_
* _if\_icmple_ succeeds if and only if _value1_ ≤ _value2_
* _if\_icmpgt_ succeeds if and only if _value1_ &gt; _value2_
* _if\_icmpge_ succeeds if and only if _value1_ ≥ _value2_

If the comparison succeeds, the unsigned _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit offset, where the offset is calculated to be \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution then proceeds at that offset from the address of the opcode of this _if\_icmp&lt;cond&gt;_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _if\_icmp&lt;cond&gt;_ instruction.

Otherwise, execution proceeds at the address of the instruction following this _if\_icmp&lt;cond&gt;_ instruction.

#### _if&lt;cond&gt;_

**Operation**

Branch if `int` comparison with zero succeeds

**Format**

  
_if&lt;cond&gt;_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_ifeq_ = 153 \(0x99\)

_ifne_ = 154 \(0x9a\)

_iflt_ = 155 \(0x9b\)

_ifge_ = 156 \(0x9c\)

_ifgt_ = 157 \(0x9d\)

_ifle_ = 158 \(0x9e\)

**Operand Stack**

..., _value_ →

...

**Description**

The _value_ must be of type `int`. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:

* _ifeq_ succeeds if and only if _value_ = 0
* _ifne_ succeeds if and only if _value_ ≠ 0
* _iflt_ succeeds if and only if _value_ &lt; 0
* _ifle_ succeeds if and only if _value_ ≤ 0
* _ifgt_ succeeds if and only if _value_ &gt; 0
* _ifge_ succeeds if and only if _value_ ≥ 0

If the comparison succeeds, the unsigned _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit offset, where the offset is calculated to be \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution then proceeds at that offset from the address of the opcode of this _if&lt;cond&gt;_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _if&lt;cond&gt;_ instruction.

Otherwise, execution proceeds at the address of the instruction following this _if&lt;cond&gt;_ instruction.

#### _ifnonnull_

**Operation**

Branch if `reference` not `null`

**Format**

  
_ifnonnull_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_ifnonnull_ = 199 \(0xc7\)

**Operand Stack**

..., _value_ →

...

**Description**

The _value_ must be of type `reference`. It is popped from the operand stack. If _value_ is not `null`, the unsigned _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit offset, where the offset is calculated to be \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution then proceeds at that offset from the address of the opcode of this _ifnonnull_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _ifnonnull_ instruction.

Otherwise, execution proceeds at the address of the instruction following this _ifnonnull_ instruction.

#### _ifnull_

**Operation**

Branch if `reference` is `null`

**Format**

  
_ifnull_  
_branchbyte1_  
_branchbyte2_  


**Forms**

_ifnull_ = 198 \(0xc6\)

**Operand Stack**

..., _value_ →

...

**Description**

The _value_ must of type `reference`. It is popped from the operand stack. If _value_ is `null`, the unsigned _branchbyte1_ and _branchbyte2_ are used to construct a signed 16-bit offset, where the offset is calculated to be \(_branchbyte1_ `<<` 8\) \| _branchbyte2_. Execution then proceeds at that offset from the address of the opcode of this _ifnull_ instruction. The target address must be that of an opcode of an instruction within the method that contains this _ifnull_ instruction.

Otherwise, execution proceeds at the address of the instruction following this _ifnull_ instruction.

#### _iinc_

**Operation**

Increment local variable by constant

**Format**

  
_iinc_  
_index_  
_const_  


**Forms**

_iinc_ = 132 \(0x84\)

**Operand Stack**

No change

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _const_ is an immediate signed byte. The local variable at _index_ must contain an `int`. The value _const_ is first sign-extended to an `int`, and then the local variable at _index_ is incremented by that amount.

**Notes**

The _iinc_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index and to increment it by a two-byte immediate signed value.

#### _iload_

**Operation**

Load `int` from local variable

**Format**

  
_iload_  
_index_  


**Forms**

_iload_ = 21 \(0x15\)

**Operand Stack**

... →

..., _value_

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at _index_ must contain an `int`. The _value_ of the local variable at _index_ is pushed onto the operand stack.

**Notes**

The _iload_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _iload\_&lt;n&gt;_

**Operation**

Load `int` from local variable

**Format**

  
_iload\_&lt;n&gt;_  


**Forms**

_iload\_0_ = 26 \(0x1a\)

_iload\_1_ = 27 \(0x1b\)

_iload\_2_ = 28 \(0x1c\)

_iload\_3_ = 29 \(0x1d\)

**Operand Stack**

... →

..., _value_

**Description**

The &lt;_n_&gt; must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at &lt;_n_&gt; must contain an `int`. The _value_ of the local variable at &lt;_n_&gt; is pushed onto the operand stack.

**Notes**

Each of the _iload\_&lt;n&gt;_ instructions is the same as _iload_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _imul_

**Operation**

Multiply `int`

**Format**

  
_imul_  


**Forms**

_imul_ = 104 \(0x68\)

**Operand Stack**

..., _value1_, _value2_ →

..., _result_

**Description**

Both _value1_ and _value2_ must be of type `int`. The values are popped from the operand stack. The `int` _result_ is _value1_ \* _value2_. The _result_ is pushed onto the operand stack.

The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type `int`. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical multiplication of the two values.

Despite the fact that overflow may occur, execution of an _imul_ instruction never throws a run-time exception.

#### _ineg_

**Operation**

Negate `int`

**Format**

  
_ineg_  


**Forms**

_ineg_ = 116 \(0x74\)

**Operand Stack**

..., _value_ →

..., _result_

**Description**

The _value_ must be of type `int`. It is popped from the operand stack. The `int` _result_ is the arithmetic negation of _value_, -_value_. The _result_ is pushed onto the operand stack.

For `int` values, negation is the same as subtraction from zero. Because the Java Virtual Machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative `int` results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown.

For all `int` values `x`, `-x` equals `(~x)+1`.

#### _instanceof_

**Operation**

Determine if object is of given type

**Format**

  
_instanceof_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_instanceof_ = 193 \(0xc1\)

**Operand Stack**

..., _objectref_ →

..., _result_

**Description**

The _objectref_, which must be of type `reference`, is popped from the operand stack. The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at the index must be a symbolic reference to a class, array, or interface type.

If _objectref_ is `null`, the _instanceof_ instruction pushes an `int` _result_ of 0 as an `int` on the operand stack.

Otherwise, the named class, array, or interface type is resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\). If _objectref_ is an instance of the resolved class or array or implements the resolved interface, the _instanceof_ instruction pushes an `int` _result_ of 1 as an `int` on the operand stack; otherwise, it pushes an `int` _result_ of 0.

The following rules are used to determine whether an _objectref_ that is not `null` is an instance of the resolved type: If S is the class of the object referred to by _objectref_ and T is the resolved class, array, or interface type, _instanceof_ determines whether _objectref_ is an instance of T as follows:

* If S is an ordinary \(nonarray\) class, then:
  * If T is a class type, then S must be the same class as T, or S must be a subclass of T;
  * If T is an interface type, then S must implement interface T.
* If S is an interface type, then:
  * If T is a class type, then T must be `Object`.
  * If T is an interface type, then T must be the same interface as S or a superinterface of S.
* If S is a class representing the array type SC`[]`, that is, an array of components of type SC, then:
  * If T is a class type, then T must be `Object`.
  * If T is an interface type, then T must be one of the interfaces implemented by arrays \(JLS §4.10.3\).
  * If T is an array type TC`[]`, that is, an array of components of type TC, then one of the following must be true:
    * TC and SC are the same primitive type.
    * TC and SC are reference types, and type SC can be cast to TC by these run-time rules.

**Linking Exceptions**

During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in [§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1) can be thrown.

**Notes**

The _instanceof_ instruction is very similar to the _checkcast_ instruction \([§_checkcast_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.checkcast)\). It differs in its treatment of `null`, its behavior when its test fails \(_checkcast_ throws an exception, _instanceof_ pushes a result code\), and its effect on the operand stack.

#### _invokedynamic_

**Operation**

Invoke dynamic method

**Format**

  
_invokedynamic_  
_indexbyte1_  
_indexbyte2_  
_0_  
_0_  


**Forms**

_invokedynamic_ = 186 \(0xba\)

**Operand Stack**

..., \[_arg1_, \[_arg2_ ...\]\] →

...

**Description**

Each specific lexical occurrence of an _invokedynamic_ instruction is called a _dynamic call site_.

First, the unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a call site specifier \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\). The values of the third and fourth operand bytes must always be zero.

The call site specifier is resolved \([§5.4.3.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.6)\) _for this specific dynamic call site_ to obtain a `reference` to a `java.lang.invoke.MethodHandle` instance that will serve as the bootstrap method, a `reference` to a `java.lang.invoke.MethodType` instance, and `reference`s to static arguments.

Next, as part of the continuing resolution of the call site specifier, the bootstrap method is invoked as if by execution of an _invokevirtual_ instruction \([§_invokevirtual_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokevirtual)\) that contains a run-time constant pool index to a symbolic reference R where:

* R is a symbolic reference to a method of a class \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\);
* for the symbolic reference to the class in which the method is to be found, R specifies `java.lang.invoke.MethodHandle`;
* for the name of the method, R specifies `invoke`;
* for the descriptor of the method, R specifies a return type of `java.lang.invoke.CallSite` and parameter types derived from the items pushed on the operand stack.

  The first three parameter types are `java.lang.invoke.MethodHandles.Lookup`, `String`, and `java.lang.invoke.MethodType`, in that order. If the call site specifier has any static arguments, then a parameter type for each argument is appended to the parameter types of the method descriptor in the order that the arguments were pushed on to the operand stack. These parameter types may be `Class`, `java.lang.invoke.MethodHandle`, `java.lang.invoke.MethodType`, `String`, `int`, `long`, `float`, or `double`.

and where it is as if the following items were pushed, in order, on the operand stack:

* the `reference` to the `java.lang.invoke.MethodHandle` object for the bootstrap method;
* a `reference` to a `java.lang.invoke.MethodHandles.Lookup` object for the class in which this dynamic call site occurs;
* a `reference` to the `String` for the method name in the call site specifier;
* the `reference` to the `java.lang.invoke.MethodType` object obtained for the method descriptor in the call site specifier;
* `reference`s to classes, method types, method handles, and string literals denoted as static arguments in the call site specifier, and numeric values \([§2.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.1), [§2.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.2)\) denoted as static arguments in the call site specifier, in the order in which they appear in the call site specifier. \(That is, no boxing occurs for primitive values.\)

The symbolic reference R describes a method which is signature polymorphic \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\). Due to the operation of _invokevirtual_ on a signature polymorphic method called `invoke`, the type descriptor of the receiving method handle \(representing the bootstrap method\) need not be semantically equal to the method descriptor specified by R. For example, the first parameter type specified by R could be `Object` instead of `java.lang.invoke.MethodHandles.Lookup`, and the return type specified by R could be `Object` instead of `java.lang.invoke.CallSite`. As long as the bootstrap method can be invoked by the `invoke` method without a `java.lang.invoke.WrongMethodTypeException` being thrown, the type descriptor of the method handle which represents the bootstrap method is arbitrary.

If the bootstrap method is a variable arity method, then some or all of the arguments on the operand stack specified above may be collected into a trailing array parameter.

The invocation of a bootstrap method occurs within a thread that is attempting resolution of the symbolic reference to the call site specifier _of this dynamic call site_. If there are several such threads, the bootstrap method may be invoked in several threads concurrently. Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions.

The result returned by the bootstrap method must be a `reference` to an object whose class is `java.lang.invoke.CallSite` or a subclass of `java.lang.invoke.CallSite`. This object is known as the _call site object_. The `reference` is popped from the operand stack used as if in the execution of an _invokevirtual_ instruction.

If several threads simultaneously execute the bootstrap method for the same dynamic call site, the Java Virtual Machine must choose one returned call site object and install it visibly to all threads. Any other bootstrap methods executing for the dynamic call site are allowed to complete, but their results are ignored, and the threads' execution of the dynamic call site proceeds with the chosen call site object.

The call site object has a type descriptor \(an instance of `java.lang.invoke.MethodType`\) which must be semantically equal to the `java.lang.invoke.MethodType` object obtained for the method descriptor in the call site specifier.

The result of successful call site specifier resolution is a call site object which is permanently bound to the dynamic call site.

The method handle represented by the target of the bound call site object is invoked. The invocation occurs as if by execution of an _invokevirtual_ instruction \([§_invokevirtual_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokevirtual)\) that indicates a run-time constant pool index to a symbolic reference to a method \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\) with the following properties:

* The method's name is `invokeExact`;
* The method's descriptor is the method descriptor in the call site specifier; and
* The method's symbolic reference to the class in which the method is to be found indicates the class `java.lang.invoke.MethodHandle`.

The operand stack will be interpreted as containing a `reference` to the target of the call site object, followed by _nargs_ argument values, where the number, type, and order of the values must be consistent with the method descriptor in the call site specifier.

**Linking Exceptions**

If resolution of the symbolic reference to the call site specifier throws an exception E, the _invokedynamic_ instruction throws a `BootstrapMethodError` that wraps E.

Otherwise, during the continuing resolution of the call site specifier, if invocation of the bootstrap method completes abruptly \([§2.6.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.5)\) because of a throw of exception E, the _invokedynamic_ instruction throws a `BootstrapMethodError` that wraps E. \(This can occur if the bootstrap method has the wrong arity, parameter type, or return type, causing `java.lang.invoke.MethodHandle` `.` `invoke` to throw `java.lang.invoke.WrongMethodTypeException`.\)

Otherwise, during the continuing resolution of the call site specifier, if the result from the bootstrap method invocation is not a `reference` to an instance of `java.lang.invoke.CallSite`, the _invokedynamic_ instruction throws a `BootstrapMethodError`.

Otherwise, during the continuing resolution of the call site specifier, if the type descriptor of the target of the call site object is not semantically equal to the method descriptor in the call site specifier, the _invokedynamic_ instruction throws a `BootstrapMethodError`.

**Run-time Exceptions**

If this specific dynamic call site completed resolution of its call site specifier, it implies that a non-`null` `reference` to an instance of `java.lang.invoke.CallSite` is bound to this dynamic call site. Therefore, the operand stack item which represents a `reference` to the target of the call site object is never `null`. Similarly, it implies that the method descriptor in the call site specifier is semantically equal to the type descriptor of the _method handle to be invoked_ as if by execution of an _invokevirtual_ instruction. Together, these invariants mean that an _invokedynamic_ instruction which is bound to a call site object never throws a `NullPointerException` or a `java.lang.invoke.WrongMethodTypeException`.

#### _invokeinterface_

**Operation**

Invoke interface method

**Format**

  
_invokeinterface_  
_indexbyte1_  
_indexbyte2_  
_count_  
_0_  


**Forms**

_invokeinterface_ = 185 \(0xb9\)

**Operand Stack**

..., _objectref_, \[_arg1_, \[_arg2_ ...\]\] →

...

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to an interface method \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor \([§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\) of the interface method as well as a symbolic reference to the interface in which the interface method is to be found. The named interface method is resolved \([§5.4.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.4)\).

The resolved interface method must not be an instance initialization method, or the class or interface initialization method \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\).

The _count_ operand is an unsigned byte that must not be zero. The _objectref_ must be of type `reference` and must be followed on the operand stack by _nargs_ argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved interface method. The value of the fourth operand byte must always be zero.

Let C be the class of _objectref_. The actual method to be invoked is selected by the following lookup procedure:

1. If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then it is the method to be invoked.
2. Otherwise, if C has a superclass, a search for a declaration of an instance method with the same name and descriptor as the resolved method is performed, starting with the direct superclass of C and continuing with the direct superclass of that class, and so forth, until a match is found or no further superclasses exist. If a match is found, then it is the method to be invoked.
3. Otherwise, if there is exactly one maximally-specific method \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) in the superinterfaces of C that matches the resolved method's name and descriptor and is not `abstract`, then it is the method to be invoked.

If the method is `synchronized`, the monitor associated with _objectref_ is entered or reentered as if by execution of a _monitorenter_ instruction \([§_monitorenter_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter)\) in the current thread.

If the method is not `native`, the _nargs_ argument values and _objectref_ are popped from the operand stack. A new frame is created on the Java Virtual Machine stack for the method being invoked. The _objectref_ and the argument values are consecutively made the values of local variables of the new frame, with _objectref_ in local variable 0, _arg1_ in local variable 1 \(or, if _arg1_ is of type `long` or `double`, in local variables 1 and 2\), and so on. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being stored in a local variable. The new frame is then made current, and the Java Virtual Machine `pc` is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.

If the method is `native` and the platform-dependent code that implements it has not yet been bound \([§5.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.6)\) into the Java Virtual Machine, that is done. The _nargs_ argument values and _objectref_ are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns:

* If the `native` method is `synchronized`, the monitor associated with _objectref_ is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread.
* If the `native` method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the `native` method and pushed onto the operand stack.

**Linking Exceptions**

During resolution of the symbolic reference to the interface method, any of the exceptions pertaining to interface method resolution \([§5.4.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.4)\) can be thrown.

Otherwise, if the resolved method is `static` or `private`, the _invokeinterface_ instruction throws an `IncompatibleClassChangeError`.

**Run-time Exceptions**

Otherwise, if _objectref_ is `null`, the _invokeinterface_ instruction throws a `NullPointerException`.

Otherwise, if the class of _objectref_ does not implement the resolved interface, _invokeinterface_ throws an `IncompatibleClassChangeError`.

Otherwise, if step 1 or step 2 of the lookup procedure selects a method that is not `public`, _invokeinterface_ throws an `IllegalAccessError`.

Otherwise, if step 1 or step 2 of the lookup procedure selects an `abstract` method, _invokeinterface_ throws an `AbstractMethodError`.

Otherwise, if step 1 or step 2 of the lookup procedure selects a `native` method and the code that implements the method cannot be bound, _invokeinterface_ throws an `UnsatisfiedLinkError`.

Otherwise, if step 3 of the lookup procedure determines there are multiple maximally-specific methods in the superinterfaces of C that match the resolved method's name and descriptor and are not `abstract`, _invokeinterface_ throws an `IncompatibleClassChangeError`

Otherwise, if step 3 of the lookup procedure determines there are zero maximally-specific methods in the superinterfaces of C that match the resolved method's name and descriptor and are not `abstract`, _invokeinterface_ throws an `AbstractMethodError`.

**Notes**

The _count_ operand of the _invokeinterface_ instruction records a measure of the number of argument values, where an argument value of type `long` or type `double` contributes two units to the _count_ value and an argument of any other type contributes one unit. This information can also be derived from the descriptor of the selected method. The redundancy is historical.

The fourth operand byte exists to reserve space for an additional operand used in certain of Oracle's Java Virtual Machine implementations, which replace the _invokeinterface_ instruction by a specialized pseudo-instruction at run time. It must be retained for backwards compatibility.

The _nargs_ argument values and _objectref_ are not one-to-one with the first _nargs_+1 local variables. Argument values of types `long` and `double` must be stored in two consecutive local variables, thus more than _nargs_ local variables may be required to pass _nargs_ argument values to the invoked method.

The selection logic allows a non-`abstract` method declared in a superinterface to be selected. Methods in interfaces are only considered if there is no matching method in the class hierarchy. In the event that there are two non-`abstract` methods in the superinterface hierarchy, with neither more specific than the other, an error occurs; there is no attempt to disambiguate \(for example, one may be the referenced method and one may be unrelated, but we do not prefer the referenced method\). On the other hand, if there are many `abstract` methods but only one non-`abstract` method, the non-`abstract` method is selected \(unless an `abstract` method is more specific\).

#### _invokespecial_

**Operation**

Invoke instance method; special handling for superclass, private, and instance initialization method invocations

**Format**

  
_invokespecial_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_invokespecial_ = 183 \(0xb7\)

**Operand Stack**

..., _objectref_, \[_arg1_, \[_arg2_ ...\]\] →

...

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a method or an interface method \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor \([§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\) of the method as well as a symbolic reference to the class or interface in which the method is to be found. The named method is resolved \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3), [§5.4.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.4)\).

If the resolved method is `protected`, and it is a member of a superclass of the current class, and the method is not declared in the same run-time package \([§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3)\) as the current class, then the class of _objectref_ must be either the current class or a subclass of the current class.

If all of the following are true, let C be the direct superclass of the current class:

* The resolved method is not an instance initialization method \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\).
* If the symbolic reference names a class \(not an interface\), then that class is a superclass of the current class.
* The `ACC_SUPER` flag is set for the `class` file \([§4.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1)\).

Otherwise, let C be the class or interface named by the symbolic reference.

The actual method to be invoked is selected by the following lookup procedure:

1. If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then it is the method to be invoked.
2. Otherwise, if C is a class and has a superclass, a search for a declaration of an instance method with the same name and descriptor as the resolved method is performed, starting with the direct superclass of C and continuing with the direct superclass of that class, and so forth, until a match is found or no further superclasses exist. If a match is found, then it is the method to be invoked.
3. Otherwise, if C is an interface and the class `Object` contains a declaration of a `public` instance method with the same name and descriptor as the resolved method, then it is the method to be invoked.
4. Otherwise, if there is exactly one maximally-specific method \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) in the superinterfaces of C that matches the resolved method's name and descriptor and is not `abstract`, then it is the method to be invoked.

The _objectref_ must be of type `reference` and must be followed on the operand stack by _nargs_ argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.

If the method is `synchronized`, the monitor associated with _objectref_ is entered or reentered as if by execution of a _monitorenter_ instruction \([§_monitorenter_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter)\) in the current thread.

If the method is not `native`, the _nargs_ argument values and _objectref_ are popped from the operand stack. A new frame is created on the Java Virtual Machine stack for the method being invoked. The _objectref_ and the argument values are consecutively made the values of local variables of the new frame, with _objectref_ in local variable 0, _arg1_ in local variable 1 \(or, if _arg1_ is of type `long` or `double`, in local variables 1 and 2\), and so on. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being stored in a local variable. The new frame is then made current, and the Java Virtual Machine `pc` is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.

If the method is `native` and the platform-dependent code that implements it has not yet been bound \([§5.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.6)\) into the Java Virtual Machine, that is done. The _nargs_ argument values and _objectref_ are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:

* If the `native` method is `synchronized`, the monitor associated with _objectref_ is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread.
* If the `native` method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the `native` method and pushed onto the operand stack.

**Linking Exceptions**

During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) can be thrown.

Otherwise, if the resolved method is an instance initialization method, and the class in which it is declared is not the class symbolically referenced by the instruction, a `NoSuchMethodError` is thrown.

Otherwise, if the resolved method is a class \(`static`\) method, the _invokespecial_ instruction throws an `IncompatibleClassChangeError`.

**Run-time Exceptions**

Otherwise, if _objectref_ is `null`, the _invokespecial_ instruction throws a `NullPointerException`.

Otherwise, if the resolved method is a `protected` method of a superclass of the current class, declared in a different run-time package, and the class of _objectref_ is not the current class or a subclass of the current class, then _invokespecial_ throws an `IllegalAccessError`.

Otherwise, if step 1, step 2, or step 3 of the lookup procedure selects an `abstract` method, _invokespecial_ throws an `AbstractMethodError`.

Otherwise, if step 1, step 2, or step 3 of the lookup procedure selects a `native` method and the code that implements the method cannot be bound, _invokespecial_ throws an `UnsatisfiedLinkError`.

Otherwise, if step 4 of the lookup procedure determines there are multiple maximally-specific methods in the superinterfaces of C that match the resolved method's name and descriptor and are not `abstract`, _invokespecial_ throws an `IncompatibleClassChangeError`

Otherwise, if step 4 of the lookup procedure determines there are zero maximally-specific methods in the superinterfaces of C that match the resolved method's name and descriptor and are not `abstract`, _invokespecial_ throws an `AbstractMethodError`.

**Notes**

The difference between the _invokespecial_ instruction and the _invokevirtual_ instruction \([§_invokevirtual_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokevirtual)\) is that _invokevirtual_ invokes a method based on the class of the object. The _invokespecial_ instruction is used to invoke instance initialization methods \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\) as well as `private` methods and methods of a superclass of the current class.

The _invokespecial_ instruction was named `invokenonvirtual` prior to JDK release 1.0.2.

The _nargs_ argument values and _objectref_ are not one-to-one with the first _nargs_+1 local variables. Argument values of types `long` and `double` must be stored in two consecutive local variables, thus more than _nargs_ local variables may be required to pass _nargs_ argument values to the invoked method.

The _invokespecial_ instruction handles invocation of a `private` interface method, a non-`abstract` interface method referenced via a direct superinterface, and a non-`abstract` interface method referenced via a superclass. In these cases, the rules for selection are essentially the same as those for _invokeinterface_ \(except that the search starts from a different class\).

#### _invokestatic_

**Operation**

Invoke a class \(`static`\) method

**Format**

  
_invokestatic_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_invokestatic_ = 184 \(0xb8\)

**Operand Stack**

..., \[_arg1_, \[_arg2_ ...\]\] →

...

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a method or an interface method \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor \([§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\) of the method as well as a symbolic reference to the class or interface in which the method is to be found. The named method is resolved \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\).

The resolved method must not be an instance initialization method, or the class or interface initialization method \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\).

The resolved method must be `static`, and therefore cannot be `abstract`.

On successful resolution of the method, the class or interface that declared the resolved method is initialized \([§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5)\) if that class or interface has not already been initialized.

The operand stack must contain _nargs_ argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved method.

If the method is `synchronized`, the monitor associated with the resolved `Class` object is entered or reentered as if by execution of a _monitorenter_ instruction \([§_monitorenter_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter)\) in the current thread.

If the method is not `native`, the _nargs_ argument values are popped from the operand stack. A new frame is created on the Java Virtual Machine stack for the method being invoked. The _nargs_ argument values are consecutively made the values of local variables of the new frame, with _arg1_ in local variable 0 \(or, if _arg1_ is of type `long` or `double`, in local variables 0 and 1\) and so on. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being stored in a local variable. The new frame is then made current, and the Java Virtual Machine `pc` is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.

If the method is `native` and the platform-dependent code that implements it has not yet been bound \([§5.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.6)\) into the Java Virtual Machine, that is done. The _nargs_ argument values are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:

* If the `native` method is `synchronized`, the monitor associated with the resolved `Class` object is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread.
* If the `native` method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the `native` method and pushed onto the operand stack.

**Linking Exceptions**

During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) can be thrown.

Otherwise, if the resolved method is an instance method, the _invokestatic_ instruction throws an `IncompatibleClassChangeError`.

**Run-time Exceptions**

Otherwise, if execution of this _invokestatic_ instruction causes initialization of the referenced class or interface, _invokestatic_ may throw an `Error` as detailed in [§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5).

Otherwise, if the resolved method is `native` and the code that implements the method cannot be bound, _invokestatic_ throws an `UnsatisfiedLinkError`.

**Notes**

The _nargs_ argument values are not one-to-one with the first _nargs_ local variables. Argument values of types `long` and `double` must be stored in two consecutive local variables, thus more than _nargs_ local variables may be required to pass _nargs_ argument values to the invoked method.

#### _invokevirtual_

**Operation**

Invoke instance method; dispatch based on class

**Format**

  
_invokevirtual_  
_indexbyte1_  
_indexbyte2_  


**Forms**

_invokevirtual_ = 182 \(0xb6\)

**Operand Stack**

..., _objectref_, \[_arg1_, \[_arg2_ ...\]\] →

...

**Description**

The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a method \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\), which gives the name and descriptor \([§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\) of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\).

The resolved method must not be an instance initialization method, or the class or interface initialization method \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\).

If the resolved method is `protected`, and it is a member of a superclass of the current class, and the method is not declared in the same run-time package \([§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3)\) as the current class, then the class of _objectref_ must be either the current class or a subclass of the current class.

_If the resolved method is not signature polymorphic_ \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\), then the _invokevirtual_ instruction proceeds as follows.

Let C be the class of _objectref_. The actual method to be invoked is selected by the following lookup procedure:

1. If C contains a declaration for an instance method `m` that overrides \([§5.4.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.5)\) the resolved method, then `m` is the method to be invoked.
2. Otherwise, if C has a superclass, a search for a declaration of an instance method that overrides the resolved method is performed, starting with the direct superclass of C and continuing with the direct superclass of that class, and so forth, until an overriding method is found or no further superclasses exist. If an overriding method is found, it is the method to be invoked.
3. Otherwise, if there is exactly one maximally-specific method \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) in the superinterfaces of C that matches the resolved method's name and descriptor and is not `abstract`, then it is the method to be invoked.

The _objectref_ must be followed on the operand stack by _nargs_ argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.

If the method is `synchronized`, the monitor associated with _objectref_ is entered or reentered as if by execution of a _monitorenter_ instruction \([§_monitorenter_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter)\) in the current thread.

If the method is not `native`, the _nargs_ argument values and _objectref_ are popped from the operand stack. A new frame is created on the Java Virtual Machine stack for the method being invoked. The _objectref_ and the argument values are consecutively made the values of local variables of the new frame, with _objectref_ in local variable 0, _arg1_ in local variable 1 \(or, if _arg1_ is of type `long` or `double`, in local variables 1 and 2\), and so on. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being stored in a local variable. The new frame is then made current, and the Java Virtual Machine `pc` is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.

If the method is `native` and the platform-dependent code that implements it has not yet been bound \([§5.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.6)\) into the Java Virtual Machine, that is done. The _nargs_ argument values and _objectref_ are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion \([§2.8.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.8.3)\) prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:

* If the `native` method is `synchronized`, the monitor associated with _objectref_ is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread.
* If the `native` method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the `native` method and pushed onto the operand stack.

_If the resolved method is signature polymorphic_ \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\), then the _invokevirtual_ instruction proceeds as follows.

First, a `reference` to an instance of `java.lang.invoke.MethodType` is obtained as if by resolution of a symbolic reference to a method type \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\) with the same parameter and return types as the descriptor of the method referenced by the _invokevirtual_ instruction.

* If the named method is `invokeExact`, the instance of `java.lang.invoke.MethodType` must be semantically equal to the type descriptor of the receiving method handle _objectref_. The _method handle to be invoked_ is _objectref_.
* If the named method is `invoke`, and the instance of `java.lang.invoke.MethodType` is semantically equal to the type descriptor of the receiving method handle _objectref_, then the _method handle to be invoked_ is _objectref_.
* If the named method is `invoke`, and the instance of `java.lang.invoke.MethodType` is not semantically equal to the type descriptor of the receiving method handle _objectref_, then the Java Virtual Machine attempts to adjust the type descriptor of the receiving method handle, as if by a call to `java.lang.invoke.MethodHandle.asType`, to obtain an exactly invokable method handle `m`. The _method handle to be invoked_ is `m`.

The _objectref_ must be followed on the operand stack by _nargs_ argument values, where the number, type, and order of the values must be consistent with the type descriptor of the method handle to be invoked. \(This type descriptor will correspond to the method descriptor appropriate for the kind of the method handle to be invoked, as specified in [§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5).\)

Then, if the method handle to be invoked has bytecode behavior, the Java Virtual Machine invokes the method handle as if by execution of the bytecode behavior associated with the method handle's kind. If the kind is 5 \(`REF_invokeVirtual`\), 6 \(`REF_invokeStatic`\), 7 \(`REF_invokeSpecial`\), 8 \(`REF_newInvokeSpecial`\), or 9 \(`REF_invokeInterface`\), then a frame will be created and made current _in the course of executing the bytecode behavior_; when the method invoked by the bytecode behavior completes \(normally or abruptly\), the _frame of its invoker_ is considered to be the frame for the method containing this _invokevirtual_ instruction.

The frame in which the bytecode behavior itself executes is not visible.

Otherwise, if the method handle to be invoked has no bytecode behavior, the Java Virtual Machine invokes it in an implementation-dependent manner.

**Linking Exceptions**

During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) can be thrown.

Otherwise, if the resolved method is a class \(`static`\) method, the _invokevirtual_ instruction throws an `IncompatibleClassChangeError`.

Otherwise, if the resolved method is signature polymorphic, then during resolution of the method type derived from the descriptor in the symbolic reference to the method, any of the exceptions pertaining to method type resolution \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\) can be thrown.

**Run-time Exceptions**

Otherwise, if _objectref_ is `null`, the _invokevirtual_ instruction throws a `NullPointerException`.

Otherwise, if the resolved method is a `protected` method of a superclass of the current class, declared in a different run-time package, and the class of _objectref_ is not the current class or a subclass of the current class, then _invokevirtual_ throws an `IllegalAccessError`.

Otherwise, if the resolved method is not signature polymorphic:

* If step 1 or step 2 of the lookup procedure selects an `abstract` method, _invokevirtual_ throws an `AbstractMethodError`.
* Otherwise, if step 1 or step 2 of the lookup procedure selects a `native` method and the code that implements the method cannot be bound, _invokevirtual_ throws an `UnsatisfiedLinkError`.
* Otherwise, if step 3 of the lookup procedure determines there are multiple maximally-specific methods in the superinterfaces of C that match the resolved method's name and descriptor and are not `abstract`, _invokevirtual_ throws an `IncompatibleClassChangeError`
* Otherwise, if step 3 of the lookup procedure determines there are zero maximally-specific methods in the superinterfaces of C that match the resolved method's name and descriptor and are not `abstract`, _invokevirtual_ throws an `AbstractMethodError`.

Otherwise, if the resolved method is signature polymorphic, then:

* If the method name is `invokeExact`, and the obtained instance of `java.lang.invoke.MethodType` is not semantically equal to the type descriptor of the receiving method handle, the _invokevirtual_ instruction throws a `java.lang.invoke.WrongMethodTypeException`.
* If the method name is `invoke`, and the obtained instance of `java.lang.invoke.MethodType` is not a valid argument to the `java.lang.invoke.MethodHandle.asType` method invoked on the receiving method handle, the _invokevirtual_ instruction throws a `java.lang.invoke.WrongMethodTypeException`.

**Notes**

The _nargs_ argument values and _objectref_ are not one-to-one with the first _nargs_+1 local variables. Argument values of types `long` and `double` must be stored in two consecutive local variables, thus more than _nargs_ local variables may be required to pass _nargs_ argument values to the invoked method.

It is possible that the symbolic reference of an _invokevirtual_ instruction resolves to an interface method. In this case, it is possible that there is no overriding method in the class hierarchy, but that a non-`abstract` interface method matches the resolved method's descriptor. The selection logic matches such a method, using the same rules as for _invokeinterface_.

