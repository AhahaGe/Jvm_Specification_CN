# 6.5. Instructions \(a\)

#### _aconst\_null_

**Operation**

Push `null`

**Format**

  
_aconst\_null_  


**Forms**

_aconst\_null_ = 1 \(0x1\)

**Operand Stack**

... →

..., `null`

**Description**

Push the `null` object `reference` onto the operand stack.

**Notes**

The Java Virtual Machine does not mandate a concrete value for `null`.

#### _aload_

**Operation**

Load `reference` from local variable

**Format**

  
_aload_  
_index_  


**Forms**

_aload_ = 25 \(0x19\)

**Operand Stack**

... →

..., _objectref_

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at _index_ must contain a `reference`. The _objectref_ in the local variable at _index_ is pushed onto the operand stack.

**Notes**

The _aload_ instruction cannot be used to load a value of type `returnAddress` from a local variable onto the operand stack. This asymmetry with the _astore_ instruction \([§_astore_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.astore)\) is intentional.

The _aload_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _aload\_&lt;n&gt;_

**Operation**

Load `reference` from local variable

**Format**

  
_aload\_&lt;n&gt;_  


**Forms**

_aload\_0_ = 42 \(0x2a\)

_aload\_1_ = 43 \(0x2b\)

_aload\_2_ = 44 \(0x2c\)

_aload\_3_ = 45 \(0x2d\)

**Operand Stack**

... →

..., _objectref_

**Description**

The &lt;_n_&gt; must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The local variable at &lt;_n_&gt; must contain a `reference`. The _objectref_ in the local variable at &lt;_n_&gt; is pushed onto the operand stack.

**Notes**

An _aload\_&lt;n&gt;_ instruction cannot be used to load a value of type `returnAddress` from a local variable onto the operand stack. This asymmetry with the corresponding _astore\_&lt;n&gt;_ instruction \([§_astore\_&lt;n&gt;_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.astore_n)\) is intentional.

Each of the _aload\_&lt;n&gt;_ instructions is the same as _aload_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _anewarray_

**Operation**

Create new array of `reference`

**Format**

  
_anewarray_  
_indexbyte1_  
_indexbyte2_  


**Forms**

anewarray = 189 \(0xbd\)

**Operand Stack**

..., _count_ →

..., _arrayref_

**Description**

The _count_ must be of type `int`. It is popped off the operand stack. The _count_ represents the number of components of the array to be created. The unsigned _indexbyte1_ and _indexbyte2_ are used to construct an index into the run-time constant pool of the current class \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\), where the value of the index is \(_indexbyte1_ `<<` 8\) \| _indexbyte2_. The run-time constant pool item at that index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\). A new array with components of that type, of length _count_, is allocated from the garbage-collected heap, and a `reference` _arrayref_ to this new array object is pushed onto the operand stack. All components of the new array are initialized to `null`, the default value for `reference` types \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\).

**Linking Exceptions**

During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in [§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1) can be thrown.

**Run-time Exceptions**

Otherwise, if _count_ is less than zero, the _anewarray_ instruction throws a `NegativeArraySizeException`.

**Notes**

The _anewarray_ instruction is used to create a single dimension of an array of object references or part of a multidimensional array.

#### _areturn_

**Operation**

Return `reference` from method

**Format**

  
_areturn_  


**Forms**

_areturn_ = 176 \(0xb0\)

**Operand Stack**

..., _objectref_ →

\[empty\]

**Description**

The _objectref_ must be of type `reference` and must refer to an object of a type that is assignment compatible \(JLS §5.2\) with the type represented by the return descriptor \([§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\) of the current method. If the current method is a `synchronized` method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\) in the current thread. If no exception is thrown, _objectref_ is popped from the operand stack of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.

The interpreter then reinstates the frame of the invoker and returns control to the invoker.

**Run-time Exceptions**

If the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the current method is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _areturn_ throws an `IllegalMonitorStateException`. This can happen, for example, if a `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is synchronized.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _areturn_ throws an `IllegalMonitorStateException`.

#### _arraylength_

**Operation**

Get length of array

**Format**

  
_arraylength_  


**Forms**

_arraylength_ = 190 \(0xbe\)

**Operand Stack**

..., _arrayref_ →

..., _length_

**Description**

The _arrayref_ must be of type `reference` and must refer to an array. It is popped from the operand stack. The _length_ of the array it references is determined. That _length_ is pushed onto the operand stack as an `int`.

**Run-time Exceptions**

If the _arrayref_ is `null`, the _arraylength_ instruction throws a `NullPointerException`.

#### _astore_

**Operation**

Store `reference` into local variable

**Format**

  
_astore_  
_index_  


**Forms**

_astore_ = 58 \(0x3a\)

**Operand Stack**

..., _objectref_ →

...

**Description**

The _index_ is an unsigned byte that must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _objectref_ on the top of the operand stack must be of type `returnAddress` or of type `reference`. It is popped from the operand stack, and the value of the local variable at _index_ is set to _objectref_.

**Notes**

The _astore_ instruction is used with an _objectref_ of type `returnAddress` when implementing the `finally` clause of the Java programming language \([§3.13](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.13)\).

The _aload_ instruction \([§_aload_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload)\) cannot be used to load a value of type `returnAddress` from a local variable onto the operand stack. This asymmetry with the _astore_ instruction is intentional.

The _astore_ opcode can be used in conjunction with the _wide_ instruction \([§_wide_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.wide)\) to access a local variable using a two-byte unsigned index.

#### _astore\_&lt;n&gt;_

**Operation**

Store `reference` into local variable

**Format**

  
_astore\_&lt;n&gt;_  


**Forms**

_astore\_0_ = 75 \(0x4b\)

_astore\_1_ = 76 \(0x4c\)

_astore\_2_ = 77 \(0x4d\)

_astore\_3_ = 78 \(0x4e\)

**Operand Stack**

..., _objectref_ →

...

**Description**

The &lt;_n_&gt; must be an index into the local variable array of the current frame \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\). The _objectref_ on the top of the operand stack must be of type `returnAddress` or of type `reference`. It is popped from the operand stack, and the value of the local variable at &lt;_n_&gt; is set to _objectref_.

**Notes**

An _astore\_&lt;n&gt;_ instruction is used with an _objectref_ of type `returnAddress` when implementing the `finally` clauses of the Java programming language \([§3.13](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.13)\).

An _aload\_&lt;n&gt;_ instruction \([§_aload\_&lt;n&gt;_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n)\) cannot be used to load a value of type `returnAddress` from a local variable onto the operand stack. This asymmetry with the corresponding _astore\_&lt;n&gt;_ instruction is intentional.

Each of the _astore\_&lt;n&gt;_ instructions is the same as _astore_ with an _index_ of &lt;_n_&gt;, except that the operand &lt;_n_&gt; is implicit.

#### _athrow_

**Operation**

Throw exception or error

**Format**

  
_athrow_  


**Forms**

_athrow_ = 191 \(0xbf\)

**Operand Stack**

..., _objectref_ →

_objectref_

**Description**

The _objectref_ must be of type `reference` and must refer to an object that is an instance of class `Throwable` or of a subclass of `Throwable`. It is popped from the operand stack. The _objectref_ is then thrown by searching the current method \([§2.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)\) for the first exception handler that matches the class of _objectref_, as given by the algorithm in [§2.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.10).

If an exception handler that matches _objectref_ is found, it contains the location of the code intended to handle this exception. The `pc` register is reset to that location, the operand stack of the current frame is cleared, _objectref_ is pushed back onto the operand stack, and execution continues.

If no matching exception handler is found in the current frame, that frame is popped. If the current frame represents an invocation of a `synchronized` method, the monitor entered or reentered on invocation of the method is exited as if by execution of a _monitorexit_ instruction \([§_monitorexit_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit)\). Finally, the frame of its invoker is reinstated, if such a frame exists, and the _objectref_ is rethrown. If no such frame exists, the current thread exits.

**Run-time Exceptions**

If _objectref_ is `null`, _athrow_ throws a `NullPointerException` instead of _objectref_.

Otherwise, if the Java Virtual Machine implementation does not enforce the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10), then if the method of the current frame is a `synchronized` method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, _athrow_ throws an `IllegalMonitorStateException` instead of the object previously being thrown. This can happen, for example, if an abruptly completing `synchronized` method contains a _monitorexit_ instruction, but no _monitorenter_ instruction, on the object on which the method is synchronized.

Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in [§2.11.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10) and if the first of those rules is violated during invocation of the current method, then _athrow_ throws an `IllegalMonitorStateException` instead of the object previously being thrown.

**Notes**

The operand stack diagram for the _athrow_ instruction may be misleading: If a handler for this exception is matched in the current method, the _athrow_ instruction discards all the values on the operand stack, then pushes the thrown object onto the operand stack. However, if no handler is matched in the current method and the exception is thrown farther up the method invocation chain, then the operand stack of the method \(if any\) that handles the exception is cleared and _objectref_ is pushed onto that empty operand stack. All intervening frames from the method that threw the exception up to, but not including, the method that handles the exception are discarded.

