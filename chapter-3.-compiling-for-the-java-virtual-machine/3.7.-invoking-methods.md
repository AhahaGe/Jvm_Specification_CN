# 3.7. Invoking Methods

The normal method invocation for a instance method dispatches on the run-time type of the object. \(They are virtual, in C++ terms.\) Such an invocation is implemented using the _invokevirtual_ instruction, which takes as its argument an index to a run-time constant pool entry giving the internal form of the binary name of the class type of the object, the name of the method to invoke, and that method's descriptor \([ยง4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\). To invoke the `addTwo` method, defined earlier as an instance method, we might write:

```text

int add12and13() {
    return addTwo(12, 13);
}

```

This compiles to:

```text
Method int add12and13()
0   aload_0             // Push local variable 0 (this)
1   bipush 12           // Push int constant 12
3   bipush 13           // Push int constant 13
5   invokevirtual #4    // Method Example.addtwo(II)I
8   ireturn             // Return int on top of operand stack;
                        // it is the int result of addTwo()
```

The invocation is set up by first pushing a `reference` to the current instance, `this`, on to the operand stack. The method invocation's arguments, `int` values `12` and `13`, are then pushed. When the frame for the `addTwo` method is created, the arguments passed to the method become the initial values of the new frame's local variables. That is, the `reference` for `this` and the two arguments, pushed onto the operand stack by the invoker, will become the initial values of local variables _0_, _1_, and _2_ of the invoked method.

Finally, `addTwo` is invoked. When it returns, its `int` return value is pushed onto the operand stack of the frame of the invoker, the `add12and13` method. The return value is thus put in place to be immediately returned to the invoker of `add12and13`.

The return from `add12and13` is handled by the _ireturn_ instruction of `add12and13`. The _ireturn_ instruction takes the `int` value returned by `addTwo`, on the operand stack of the current frame, and pushes it onto the operand stack of the frame of the invoker. It then returns control to the invoker, making the invoker's frame current. The Java Virtual Machine provides distinct return instructions for many of its numeric and `reference` data types, as well as a _return_ instruction for methods with no return value. The same set of return instructions is used for all varieties of method invocations.

The operand of the _invokevirtual_ instruction \(in the example, the run-time constant pool index _\#4_\) is not the offset of the method in the class instance. The compiler does not know the internal layout of a class instance. Instead, it generates symbolic references to the methods of an instance, which are stored in the run-time constant pool. Those run-time constant pool items are resolved at run-time to determine the actual method location. The same is true for all other Java Virtual Machine instructions that access class instances.

Invoking `addTwoStatic`, a class \(`static`\) variant of `addTwo`, is similar, as shown:

```text

int add12and13() {
    return addTwoStatic(12, 13);
}

```

although a different Java Virtual Machine method invocation instruction is used:

```text
Method int add12and13()
0   bipush 12
2   bipush 13
4   invokestatic #3     // Method Example.addTwoStatic(II)I
7   ireturn
```

Compiling an invocation of a class \(`static`\) method is very much like compiling an invocation of an instance method, except this is not passed by the invoker. The method arguments will thus be received beginning with local variable _0_ \([ยง3.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.6)\). The _invokestatic_ instruction is always used to invoke class methods.

The _invokespecial_ instruction must be used to invoke instance initialization methods \([ยง3.8](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.8)\). It is also used when invoking methods in the superclass \(`super`\) and when invoking `private` methods. For instance, given classes `Near` and `Far` declared as:

```text

class Near {
    int it;
    public int getItNear() {
        return getIt();
    }
    private int getIt() {
        return it;
    }
}

class Far extends Near {
    int getItFar() {
        return super.getItNear();
    }
}

```

the method `Near.getItNear` \(which invokes a `private` method\) becomes:

```text
Method int getItNear()
0   aload_0
1   invokespecial #5    // Method Near.getIt()I
4   ireturn
```

The method `Far.getItFar` \(which invokes a superclass method\) becomes:

```text
Method int getItFar()
0   aload_0
1   invokespecial #4    // Method Near.getItNear()I
4   ireturn
```

Note that methods called using the _invokespecial_ instruction always pass `this` to the invoked method as its first argument. As usual, it is received in local variable _0_.

To invoke the target of a method handle, a compiler must form a method descriptor that records the actual argument and return types. A compiler may not perform method invocation conversions on the arguments; instead, it must push them on the stack according to their own unconverted types. The compiler arranges for a `reference` to the method handle object to be pushed on the stack before the arguments, as usual. The compiler emits an _invokevirtual_ instruction that references a descriptor which describes the argument and return types. By special arrangement with method resolution \([ยง5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\), an _invokevirtual_ instruction which invokes the `invokeExact` or `invoke` methods of `java.lang.invoke.MethodHandle` will always link, provided the method descriptor is syntactically well-formed and the types named in the descriptor can be resolved.

