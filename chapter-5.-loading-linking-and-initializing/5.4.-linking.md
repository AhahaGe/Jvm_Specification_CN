# 5.4. Linking

Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type \(if it is an array type\), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.

This specification allows an implementation flexibility as to when linking activities \(and, because of recursion, loading\) take place, provided that all of the following properties are maintained:

* A class or interface is completely loaded before it is linked.
* A class or interface is completely verified and prepared before it is initialized.
* Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.

For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used \("lazy" or "late" resolution\), or to resolve them all at once when the class is being verified \("eager" or "static" resolution\). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Whichever strategy is followed, any error detected during resolution must be thrown at a point in the program that \(directly or indirectly\) uses a symbolic reference to the class or interface.

Because linking involves the allocation of new data structures, it may fail with an `OutOfMemoryError`.

#### 5.4.1. Verification

_Verification_ \([§4.10](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10)\) ensures that the binary representation of a class or interface is structurally correct \([§4.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.9)\). Verification may cause additional classes and interfaces to be loaded \([§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3)\) but need not cause them to be verified or prepared.

If the binary representation of a class or interface does not satisfy the static or structural constraints listed in [§4.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.9), then a `VerifyError` must be thrown at the point in the program that caused the class or interface to be verified.

If an attempt by the Java Virtual Machine to verify a class or interface fails because an error is thrown that is an instance of `LinkageError` \(or a subclass\), then subsequent attempts to verify the class or interface always fail with the same error that was thrown as a result of the initial verification attempt.

#### 5.4.2. Preparation

_Preparation_ involves creating the static fields for a class or interface and initializing such fields to their default values \([§2.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3), [§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization \([§5.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5)\), not preparation.

During preparation of a class or interface C, the Java Virtual Machine also imposes loading constraints \([§5.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4)\). Let `L1` be the defining loader of C. For each method `m` declared in C that overrides \([§5.4.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.5)\) a method declared in a superclass or superinterface `<`D, `L2>`, the Java Virtual Machine imposes the following loading constraints:

Given that the return type of `m` is Tr, and that the formal parameter types of `m` are Tf1, ..., Tfn, then:

If Tr not an array type, let T0 be Tr; otherwise, let T0 be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tr.

For _i_ = 1 to _n_: If Tfi is not an array type, let Ti be Tfi; otherwise, let Ti be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tfi.

Then Ti`L1` = Ti`L2` for _i_ = 0 to _n_.

Furthermore, if C implements a method `m` declared in a superinterface `<`I, `L3>` of C, but C does not itself declare the method `m`, then let `<`D, `L2>` be the superclass of C that declares the implementation of method `m` inherited by C. The Java Virtual Machine imposes the following constraints:

Given that the return type of `m` is Tr, and that the formal parameter types of `m` are Tf1, ..., Tfn, then:

If Tr not an array type, let T0 be Tr; otherwise, let T0 be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tr.

For _i_ = 1 to _n_: If Tfi is not an array type, let Ti be Tfi; otherwise, let Ti be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tfi.

Then Ti`L2` = Ti`L3` for _i_ = 0 to _n_.

Preparation may occur at any time following creation but must be completed prior to initialization.

#### 5.4.3. Resolution

The Java Virtual Machine instructions _anewarray_, _checkcast_, _getfield_, _getstatic_, _instanceof_, _invokedynamic_, _invokeinterface_, _invokespecial_, _invokestatic_, _invokevirtual_, _ldc_, _ldc\_w_, _multianewarray_, _new_, _putfield_, and _putstatic_ make symbolic references to the run-time constant pool. Execution of any of these instructions requires resolution of its symbolic reference.

_Resolution_ is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.

Resolution of the symbolic reference of one occurrence of an _invokedynamic_ instruction _does not_ imply that the same symbolic reference is considered resolved for any other _invokedynamic_ instruction.

For all other instructions above, resolution of the symbolic reference of one occurrence of an instruction _does_ imply that the same symbolic reference is considered resolved for any other non-_invokedynamic_ instruction.

\(The above text implies that the concrete value determined by resolution for a specific _invokedynamic_ instruction is a call site object bound to that specific _invokedynamic_ instruction.\)

Resolution can be attempted on a symbolic reference that has already been resolved. An attempt to resolve a symbolic reference that has already successfully been resolved always succeeds trivially and always results in the same entity produced by the initial resolution of that reference.

If an error occurs during resolution of a symbolic reference, then an instance of `IncompatibleClassChangeError` \(or a subclass\) must be thrown at a point in the program that \(directly or indirectly\) uses the symbolic reference.

If an attempt by the Java Virtual Machine to resolve a symbolic reference fails because an error is thrown that is an instance of `LinkageError` \(or a subclass\), then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.

A symbolic reference to a call site specifier by a specific _invokedynamic_ instruction must not be resolved prior to execution of that instruction.

In the case of failed resolution of an _invokedynamic_ instruction, the bootstrap method is not re-executed on subsequent resolution attempts.

Certain of the instructions above require additional linking checks when resolving symbolic references. For instance, in order for a _getfield_ instruction to successfully resolve the symbolic reference to the field on which it operates, it must not only complete the field resolution steps given in [§5.4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2) but also check that the field is not `static`. If it is a `static` field, a linking exception must be thrown.

Notably, in order for an _invokedynamic_ instruction to successfully resolve the symbolic reference to a call site specifier, the bootstrap method specified therein must complete normally and return a suitable call site object. If the bootstrap method completes abruptly or returns an unsuitable call site object, a linking exception must be thrown.

Linking exceptions generated by checks that are specific to the execution of a particular Java Virtual Machine instruction are given in the description of that instruction and are not covered in this general discussion of resolution. Note that such exceptions, although described as part of the execution of Java Virtual Machine instructions rather than resolution, are still properly considered failures of resolution.

The following sections describe the process of resolving a symbolic reference in the run-time constant pool \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\) of a class or interface D. Details of resolution differ with the kind of symbolic reference to be resolved.

**5.4.3.1. Class and Interface Resolution**

To resolve an unresolved symbolic reference from D to a class or interface C denoted by `N`, the following steps are performed:

1. The defining class loader of D is used to create a class or interface denoted by `N`. This class or interface is C. The details of the process are given in [§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3).

   Any exception that can be thrown as a result of failure of class or interface creation can thus be thrown as a result of failure of class and interface resolution.

2. If C is an array class and its element type is a `reference` type, then a symbolic reference to the class or interface representing the element type is resolved by invoking the algorithm in [§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1) recursively.
3. Finally, access permissions to C are checked.
   * If C is not accessible \([§5.4.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4)\) to D, class or interface resolution throws an `IllegalAccessError`.

     This condition can occur, for example, if C is a class that was originally declared to be `public` but was changed to be non-`public` after D was compiled.

If steps 1 and 2 succeed but step 3 fails, C is still valid and usable. Nevertheless, resolution fails, and D is prohibited from accessing C.

**5.4.3.2. Field Resolution**

To resolve an unresolved symbolic reference from D to a field in a class or interface C, the symbolic reference to C given by the field reference must first be resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\). Therefore, any exception that can be thrown as a result of failure of resolution of a class or interface reference can be thrown as a result of failure of field resolution. If the reference to C can be successfully resolved, an exception relating to the failure of resolution of the field reference itself can be thrown.

When resolving a field reference, field resolution first attempts to look up the referenced field in C and its superclasses:

1. If C declares a field with the name and descriptor specified by the field reference, field lookup succeeds. The declared field is the result of the field lookup.
2. Otherwise, field lookup is applied recursively to the direct superinterfaces of the specified class or interface C.
3. Otherwise, if C has a superclass S, field lookup is applied recursively to S.
4. Otherwise, field lookup fails.

Then:

* If field lookup fails, field resolution throws a `NoSuchFieldError`.
* Otherwise, if field lookup succeeds but the referenced field is not accessible \([§5.4.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4)\) to D, field resolution throws an `IllegalAccessError`.
* Otherwise, let `<`E, `L1>` be the class or interface in which the referenced field is actually declared and let `L2` be the defining loader of D.

  Given that the type of the referenced field is Tf, let T be Tf if Tf is not an array type, and let T be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tf otherwise.

  The Java Virtual Machine must impose the loading constraint that T`L1` = T`L2` \([§5.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4)\).

**5.4.3.3. Method Resolution**

To resolve an unresolved symbolic reference from D to a method in a class C, the symbolic reference to C given by the method reference is first resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\). Therefore, any exception that can be thrown as a result of failure of resolution of a class reference can be thrown as a result of failure of method resolution. If the reference to C can be successfully resolved, exceptions relating to the resolution of the method reference itself can be thrown.

When resolving a method reference:

1. If C is an interface, method resolution throws an `IncompatibleClassChangeError`.
2. Otherwise, method resolution attempts to locate the referenced method in C and its superclasses:
   * If C declares exactly one method with the name specified by the method reference, and the declaration is a signature polymorphic method \([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)\), then method lookup succeeds. All the class names mentioned in the descriptor are resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\).

     _The resolved method is the signature polymorphic method declaration._ It is not necessary for C to declare a method with the descriptor specified by the method reference.

   * Otherwise, if C declares a method with the name and descriptor specified by the method reference, method lookup succeeds.
   * Otherwise, if C has a superclass, step 2 of method resolution is recursively invoked on the direct superclass of C.
3. Otherwise, method resolution attempts to locate the referenced method in the superinterfaces of the specified class C:
   * If the _maximally-specific superinterface methods_ of C for the name and descriptor specified by the method reference include exactly one method that does not have its `ACC_ABSTRACT` flag set, then this method is chosen and method lookup succeeds.
   * Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its `ACC_PRIVATE` flag nor its `ACC_STATIC` flag set, one of these is arbitrarily chosen and method lookup succeeds.
   * Otherwise, method lookup fails.

A _maximally-specific superinterface method_ of a class or interface C for a particular method name and descriptor is any method for which all of the following are true:

* The method is declared in a superinterface \(direct or indirect\) of C.
* The method is declared with the specified name and descriptor.
* The method has neither its `ACC_PRIVATE` flag nor its `ACC_STATIC` flag set.
* Where the method is declared in interface I, there exists no other maximally-specific superinterface method of C with the specified name and descriptor that is declared in a subinterface of I.

The result of method resolution is determined by whether method lookup succeeds or fails:

* If method lookup fails, method resolution throws a `NoSuchMethodError`.
* Otherwise, if method lookup succeeds and the referenced method is not accessible \([§5.4.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4)\) to D, method resolution throws an `IllegalAccessError`.
* Otherwise, let `<`E, `L1>` be the class or interface in which the referenced method `m` is actually declared, and let `L2` be the defining loader of D.

  Given that the return type of `m` is Tr, and that the formal parameter types of `m` are Tf1, ..., Tfn, then:

  If Tr is not an array type, let T0 be Tr; otherwise, let T0 be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tr.

  For _i_ = 1 to _n_: If Tfi is not an array type, let Ti be Tfi; otherwise, let Ti be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tfi.

  The Java Virtual Machine must impose the loading constraints Ti`L1` = Ti`L2` for _i_ = 0 to _n_ \([§5.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4)\).

When resolution searches for a method in the class's superinterfaces, the best outcome is to identify a maximally-specific non-`abstract` method. It is possible that this method will be chosen by method selection, so it is desirable to add class loader constraints for it.

Otherwise, the result is nondeterministic. This is not new: _The Java® Virtual Machine Specification_ has never identified exactly which method is chosen, and how "ties" should be broken. Prior to Java SE 8, this was mostly an unobservable distinction. However, beginning with Java SE 8, the set of interface methods is more heterogenous, so care must be taken to avoid problems with nondeterministic behavior. Thus:

* Superinterface methods that are `private` and `static` are ignored by resolution. This is consistent with the Java programming language, where such interface methods are not inherited.
* Any behavior controlled by the resolved method should not depend on whether the method is `abstract` or not.

Note that if the result of resolution is an `abstract` method, the referenced class C may be non-`abstract`. Requiring C to be `abstract` would conflict with the nondeterministic choice of superinterface methods. Instead, resolution assumes that the run time class of the invoked object has a concrete implementation of the method.

**5.4.3.4. Interface Method Resolution**

To resolve an unresolved symbolic reference from D to an interface method in an interface C, the symbolic reference to C given by the interface method reference is first resolved \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\). Therefore, any exception that can be thrown as a result of failure of resolution of an interface reference can be thrown as a result of failure of interface method resolution. If the reference to C can be successfully resolved, exceptions relating to the resolution of the interface method reference itself can be thrown.

When resolving an interface method reference:

1. If C is not an interface, interface method resolution throws an `IncompatibleClassChangeError`.
2. Otherwise, if C declares a method with the name and descriptor specified by the interface method reference, method lookup succeeds.
3. Otherwise, if the class `Object` declares a method with the name and descriptor specified by the interface method reference, which has its `ACC_PUBLIC` flag set and does not have its `ACC_STATIC` flag set, method lookup succeeds.
4. Otherwise, if the maximally-specific superinterface methods \([§5.4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3)\) of C for the name and descriptor specified by the method reference include exactly one method that does not have its `ACC_ABSTRACT` flag set, then this method is chosen and method lookup succeeds.
5. Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its `ACC_PRIVATE` flag nor its `ACC_STATIC` flag set, one of these is arbitrarily chosen and method lookup succeeds.
6. Otherwise, method lookup fails.

The result of interface method resolution is determined by whether method lookup succeeds or fails:

* If method lookup fails, interface method resolution throws a `NoSuchMethodError`.
* If method lookup succeeds and the referenced method is not accessible \([§5.4.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4)\) to D, interface method resolution throws an `IllegalAccessError`.
* Otherwise, let `<`E, `L1>` be the class or interface in which the referenced interface method `m` is actually declared, and let `L2` be the defining loader of D.

  Given that the return type of `m` is Tr, and that the formal parameter types of `m` are Tf1, ..., Tfn, then:

  If Tr is not an array type, let T0 be Tr; otherwise, let T0 be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tr.

  For _i_ = 1 to _n_: If Tfi is not an array type, let Ti be Tfi; otherwise, let Ti be the element type \([§2.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4)\) of Tfi.

  The Java Virtual Machine must impose the loading constraints Ti`L1` = Ti`L2` for _i_ = 0 to _n_ \([§5.3.4](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4)\).

The clause about accessibility is necessary because interface method resolution may pick a `private` method of interface C. \(Prior to Java SE 8, the result of interface method resolution could be a non-`public` method of class `Object` or a `static` method of class `Object`; such results were not consistent with the inheritance model of the Java programming language, and are disallowed in Java SE 8 and above.\)

**5.4.3.5. Method Type and Method Handle Resolution**

To resolve an unresolved symbolic reference to a method type, it is as if resolution occurs of unresolved symbolic references to classes and interfaces \([§5.4.3.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1)\) whose names correspond to the types given in the method descriptor \([§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\).

Any exception that can be thrown as a result of failure of resolution of a class reference can thus be thrown as a result of failure of method type resolution.

The result of successful method type resolution is a `reference` to an instance of `java.lang.invoke.MethodType` which represents the method descriptor.

Method type resolution occurs regardless of whether the run time constant pool actually contains symbolic references to classes and interfaces indicated in the method descriptor. Also, the resolution is deemed to occur on _unresolved_ symbolic references, so a failure to resolve one method type will not necessarily lead to a later failure to resolve another method type with the same textual method descriptor, if suitable classes and interfaces can be loaded by the later time.

Resolution of an unresolved symbolic reference to a method handle is more complicated. Each method handle resolved by the Java Virtual Machine has an equivalent instruction sequence called its _bytecode behavior_, indicated by the method handle's _kind_. The integer values and descriptions of the nine kinds of method handle are given in [Table 5.4.3.5-A](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5-220).

Symbolic references by an instruction sequence to fields or methods are indicated by `C.x:T`, where `x` and `T` are the name and descriptor \([§4.3.2](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2), [§4.3.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3)\) of the field or method, and `C` is the class or interface in which the field or method is to be found.

**Table 5.4.3.5-A. Bytecode Behaviors for Method Handles**

| Kind | Description | Interpretation |
| :--- | :--- | :--- |
| 1 | `REF_getField` | `getfield C.f:T` |
| 2 | `REF_getStatic` | `getstatic C.f:T` |
| 3 | `REF_putField` | `putfield C.f:T` |
| 4 | `REF_putStatic` | `putstatic C.f:T` |
| 5 | `REF_invokeVirtual` | `invokevirtual C.m:(A*)T` |
| 6 | `REF_invokeStatic` | `invokestatic C.m:(A*)T` |
| 7 | `REF_invokeSpecial` | `invokespecial C.m:(A*)T` |
| 8 | `REF_newInvokeSpecial` | `new C; dup; invokespecial C.<init>`:\(A\*\)V |
| 9 | `REF_invokeInterface` | `invokeinterface C.m:(A*)T` |

Let `MH` be the symbolic reference to a method handle \([§5.1](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1)\) being resolved. Then:

* Let R be the symbolic reference to the field or method contained within `MH`.

  \(R is derived from the `CONSTANT_Fieldref`, `CONSTANT_Methodref`, or `CONSTANT_InterfaceMethodref` structure referred to by the `reference_index` item of the `CONSTANT_MethodHandle` from which `MH` is derived.\)

* Let T be the type of the field referenced by R, or the return type of the method referenced by R. Let A\* be the sequence \(perhaps empty\) of parameter types of the method referenced by R.

  \(T and A\* are derived from the `CONSTANT_NameAndType` structure referred to by the `name_and_type_index` item in the `CONSTANT_Fieldref`, `CONSTANT_Methodref`, or `CONSTANT_InterfaceMethodref` structure from which R is derived.\)

To resolve `MH`, all symbolic references to classes, interfaces, fields, and methods in `MH`'s bytecode behavior are resolved, using the following three steps:

* First, R is resolved.
* Second, resolution occurs as if of unresolved symbolic references to classes and interfaces whose names correspond to each type in A\*, and to the type T, in that order.
* Third, a reference to an instance of `java.lang.invoke.MethodType` is obtained as if by resolution of an unresolved symbolic reference to a method type that contains the method descriptor specified in [Table 5.4.3.5-B](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5-260) for the kind of `MH`.

  It is as if the symbolic reference to a method handle contains a symbolic reference to the method type that the resolved method handle will eventually have. The detailed structure of the method type is obtained by inspecting [Table 5.4.3.5-B](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5-260).

In each step, any exception that can be thrown as a result of failure of resolution of a class or interface or field or method reference can be thrown as a result of failure of method handle resolution.

The intent is that resolving a method handle can be done in exactly the same circumstances that the Java Virtual Machine would successfully resolve the symbolic references in the bytecode behavior. In particular, method handles to `private` and `protected` members can be created in exactly those classes for which the corresponding normal accesses are legal.

**Table 5.4.3.5-B. Method Descriptors for Method Handles**

| Kind | Description | Method descriptor |
| :--- | :--- | :--- |
| 1 | `REF_getField` | `(C)T` |
| 2 | `REF_getStatic` | `()T` |
| 3 | `REF_putField` | `(C,T)V` |
| 4 | `REF_putStatic` | `(T)V` |
| 5 | `REF_invokeVirtual` | `(C,A*)T` |
| 6 | `REF_invokeStatic` | `(A*)T` |
| 7 | `REF_invokeSpecial` | `(C,A*)T` |
| 8 | `REF_newInvokeSpecial` | `(A*)C` |
| 9 | `REF_invokeInterface` | `(C,A*)T` |

The result of successful method handle resolution is a `reference` to an instance of `java.lang.invoke.MethodHandle` which represents the method handle `MH`.

The type descriptor of this `java.lang.invoke.MethodHandle` instance is the `java.lang.invoke.MethodType` instance produced in the third step of method handle resolution above.

The type descriptor of a method handle is such that a valid call to `invokeExact` in `java.lang.invoke.MethodHandle` on the method handle has exactly the same stack effects as the bytecode behavior. Calling this method handle on a valid set of arguments has exactly the same effect and returns the same result \(if any\) as the corresponding bytecode behavior.

If the method referenced by R has the `ACC_VARARGS` flag set \([§4.6](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6)\), then the `java.lang.invoke.MethodHandle` instance is a variable arity method handle; otherwise, it is a fixed arity method handle.

A variable arity method handle performs argument list boxing \(JLS §15.12.4.2\) when invoked via `invoke`, while its behavior with respect to `invokeExact` is as if the `ACC_VARARGS` flag were not set.

Method handle resolution throws an `IncompatibleClassChangeError` if the method referenced by R has the `ACC_VARARGS` flag set and either A\* is an empty sequence or the last parameter type in A\* is not an array type. That is, creation of a variable arity method handle fails.

An implementation of the Java Virtual Machine is not required to intern method types or method handles. That is, two distinct symbolic references to method types or method handles which are structurally identical might not resolve to the same instance of `java.lang.invoke.MethodType` or `java.lang.invoke.MethodHandle` respectively.

The `java.lang.invoke.MethodHandles` class in the Java SE platform API allows creation of method handles with no bytecode behavior. Their behavior is defined by the method of `java.lang.invoke.MethodHandles` that creates them. For example, a method handle may, when invoked, first apply transformations to its argument values, then supply the transformed values to the invocation of another method handle, then apply a transformation to the value returned from that invocation, then return the transformed value as its own result.

**5.4.3.6. Call Site Specifier Resolution**

To resolve an unresolved symbolic reference to a call site specifier involves three steps:

* A call site specifier gives a symbolic reference to a method handle which is to serve as the _bootstrap method_ for a dynamic call site \([§4.7.23](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.23)\). The method handle is resolved to obtain a `reference` to an instance of `java.lang.invoke.MethodHandle` \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\).
* A call site specifier gives a method descriptor, _TD_. A `reference` to an instance of `java.lang.invoke.MethodType` is obtained as if by resolution of a symbolic reference to a method type with the same parameter and return types as _TD_ \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\).
* A call site specifier gives zero or more _static arguments_, which communicate application-specific metadata to the bootstrap method. Any static arguments which are symbolic references to classes, method handles, or method types are resolved, as if by invocation of the _ldc_ instruction \([§_ldc_](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ldc)\), to obtain `reference`s to `Class` objects, `java.lang.invoke.MethodHandle` objects, and `java.lang.invoke.MethodType` objects respectively. Any static arguments that are string literals are used to obtain `reference`s to `String` objects.

The result of call site specifier resolution is a tuple consisting of:

* the `reference` to an instance of `java.lang.invoke.MethodHandle`,
* the `reference` to an instance of `java.lang.invoke.MethodType`,
* the `reference`s to instances of `Class`, `java.lang.invoke.MethodHandle`, `java.lang.invoke.MethodType`, and `String`.

During resolution of the symbolic reference to the method handle in the call site specifier, or resolution of the symbolic reference to the method type for the method descriptor in the call site specifier, or resolution of a symbolic reference to any static argument, any of the exceptions pertaining to method type or method handle resolution may be thrown \([§5.4.3.5](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5)\).

#### 5.4.4. Access Control

A class or interface C is _accessible_ to a class or interface D if and only if either of the following is true:

* C is `public`.
* C and D are members of the same run-time package \([§5.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3)\).

A field or method R is accessible to a class or interface D if and only if any of the following is true:

* R is `public`.
* R is `protected` and is declared in a class C, and D is either a subclass of C or C itself. Furthermore, if R is not `static`, then the symbolic reference to R must contain a symbolic reference to a class T, such that T is either a subclass of D, a superclass of D, or D itself.
* R is either `protected` or has default access \(that is, neither `public` nor `protected` nor `private`\), and is declared by a class in the same run-time package as D.
* R is `private` and is declared in D.

This discussion of access control omits a related restriction on the target of a `protected` field access or method invocation \(the target must be of class D or a subtype of D\). That requirement is checked as part of the verification process \([§4.10.1.8](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.1.8)\); it is not part of link-time access control.

#### 5.4.5. Overriding

An instance method `mC` declared in class C overrides another instance method `mA` declared in class A iff either `mC` is the same as `mA`, or all of the following are true:

* C is a subclass of A.
* `mC` has the same name and descriptor as `mA`.
* `mC` is not marked `ACC_PRIVATE`.
* One of the following is true:
  * `mA` is marked `ACC_PUBLIC`; or is marked `ACC_PROTECTED`; or is marked neither `ACC_PUBLIC` nor `ACC_PROTECTED` nor `ACC_PRIVATE` and A belongs to the same run-time package as C.
  * `mC` overrides a method `m'` \(`m'` distinct from `mC` and `mA`\) such that `m'` overrides `mA`.

